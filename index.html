<!DOCTYPE html>
<html lang="pt-BR">
<head>
<script src="https://unpkg.com/lucide@latest"></script>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Board Browser</title>
<link rel="stylesheet" href="css/boardbrowser.css">

</head>
<body>
  <div id="sidebar" class="sidebar">
    <div id="sidebar-header">
      <span id="sidebar-title"></span>
      <button id="sidebar-close">×</button>
    </div>
    <div id="sidebar-content"></div>
  </div>
  <div id="toolbar">
    
    


    <button class="downloads-btn" onclick="openDownloadsSidebar()">
        <i data-lucide="download"></i>
        <span class="downloads-badge" id="downloadsBadge">0</span>
    </button>
    <button id="btnFavorites"><i data-lucide="star"></i></button>
    <button id="btnMoreOptions"><i data-lucide="grip"></i></button>
    <div id="more-options-menu">
      <button id="btnExportBoards">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-up-icon lucide-file-up"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M12 12v6"/><path d="m15 15-3-3-3 3"/></svg>
        Export Boards</button>
      <button id="btnImportBoards">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-down-icon lucide-file-down"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M12 18v-6"/><path d="m9 15 3 3 3-3"/></svg>
        Import Boards</button>
      <button id="btnHistory">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-history-icon lucide-history"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M12 7v5l4 2"/></svg>
        History</button>
      <button id="btnPasswordsGenerator">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-lock-icon lucide-lock"><rect width="18" height="11" x="3" y="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
        Password Generator</button>
      <button id="btnRenameBoards">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-pencil-icon lucide-pencil"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"/><path d="m15 5 4 4"/></svg>
        Rename Boards</button>
      <button id="btnSettings">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-settings-icon lucide-settings"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>
        Settings</button>
        <button id="btnCard">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-id-card-icon lucide-id-card"><path d="M16 10h2"/><path d="M16 14h2"/><path d="M6.17 15a3 3 0 0 1 5.66 0"/><circle cx="9" cy="11" r="2"/><rect x="2" y="5" width="20" height="14" rx="2"/></svg>
            Member Card
        </button>
      <button id="btnAbout">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-info-icon lucide-info"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
        About</button>
    </div>

    <div style="position: relative;">
      <button id="btnNewTab"><i data-lucide="plus"></i></button>
      <div id="dropdown-menu">
        <button id="btnCreateTab">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-earth-icon lucide-earth"><path d="M21.54 15H17a2 2 0 0 0-2 2v4.54"/><path d="M7 3.34V5a3 3 0 0 0 3 3a2 2 0 0 1 2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.1.9-2 2-2h3.17"/><path d="M11 21.95V18a2 2 0 0 0-2-2a2 2 0 0 1-2-2v-1a2 2 0 0 0-2-2H2.05"/><circle cx="12" cy="12" r="10"/></svg>
            New Webview</button>
        <button id="btnCreateTabAnon">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-earth-lock-icon lucide-earth-lock"><path d="M7 3.34V5a3 3 0 0 0 3 3"/><path d="M11 21.95V18a2 2 0 0 0-2-2 2 2 0 0 1-2-2v-1a2 2 0 0 0-2-2H2.05"/><path d="M21.54 15H17a2 2 0 0 0-2 2v4.54"/><path d="M12 2a10 10 0 1 0 9.54 13"/><path d="M20 6V4a2 2 0 1 0-4 0v2"/><rect width="8" height="5" x="14" y="6" rx="1"/></svg>
            New P. Webview</button>
        <button id="btnCreateTextField">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-type-icon lucide-file-type"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M9 13v-1h6v1"/><path d="M12 12v6"/><path d="M11 18h2"/></svg>
            Text field</button>
        <button id="btnCreateList">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-list-checks-icon lucide-list-checks"><path d="m3 17 2 2 4-4"/><path d="m3 7 2 2 4-4"/><path d="M13 6h8"/><path d="M13 12h8"/><path d="M13 18h8"/></svg>
            List</button>
        <button id="btnCreateBoard">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-presentation-icon lucide-presentation"><path d="M2 3h20"/><path d="M21 3v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V3"/><path d="m7 21 5-5 5 5"/></svg>
            New Board</button>
        <button id="btnQuickSearch"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search-icon lucide-search"><path d="m21 21-4.34-4.34"/><circle cx="11" cy="11" r="8"/></svg>
            Quick Search</button>
        
      </div>
    </div>

    <!-- Ferramentas de desenho e mover -->
    <div id="drawing-tools" style="position: relative;">
      <button id="btnMoveMode" title="Move mode"><i data-lucide="move"></i></button>
      <button id="btnBrush" title="Brush tool"><i data-lucide="paintbrush"></i></button>
      <button id="btnEraser" title="Eraser tool"><i data-lucide="eraser"></i></button>
      <button id="btnClean" title="Clean tool"><i data-lucide="trash-2"></i></button>
      <div id="color-picker-menu">
        <div class="color-option selected" style="background-color: #ff0000;" data-color="#ff0000"></div>
        <div class="color-option" style="background-color: #00ff00;" data-color="#00ff00"></div>
        <div class="color-option" style="background-color: #0000ff;" data-color="#0000ff"></div>
        <div class="color-option" style="background-color: #ffff00;" data-color="#ffff00"></div>
        <div class="color-option" style="background-color: #ff00ff;" data-color="#ff00ff"></div>
        <div class="color-option" style="background-color: #00ffff;" data-color="#00ffff"></div>
        <div class="color-option" style="background-color: #000000;" data-color="#000000"></div>
        <div class="color-option" style="background-color: #ffffff;" data-color="#ffffff"></div>
        <input type="range" id="brush-size-control" min="1" max="50" value="5">
        <span id="brush-size-value">5px</span>
      </div>
    </div>

    <div id="boards-container"></div>
  </div>

  <div id="desktop-container">
    <div id="desktop"></div>
    <canvas id="drawing-canvas"></canvas>
  </div>

  <div id="zoom-area-trigger"></div>
  <div id="zoom-controls">
    <button id="zoom-out">-</button>
    <input type="range" id="zoom-slider" min="30" max="150" value="100">
    <button id="zoom-in">+</button>
    <span id="zoom-level">100%</span>
    <button id="reset-zoom">⟲</button>
  </div>


  <div class="modal-overlay" id="iconModal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <h3 class="modal-title">Change App Icon</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="icons-grid" id="iconsGrid">
                    <!-- Ícones serão adicionados dinamicamente aqui -->
                </div>
            </div>
        </div>
    </div>

  
  
  <div id="chatModal" class="modal-overlay">
    <div class="chat-container">
        <div class="chat-header">
            <h3>AI Assistant</h3>
            <button class="export-chat">Export in Text Field</button>
            <button class="close-chat">&times;</button>
        </div>
        
        <div class="messages-container" id="chatMessages">
            <!-- Mensagens aparecerão aqui -->
        </div>
        
        <div class="input-area">
            <input type="text" id="chatInput" placeholder="Type your message...">
            <button id="sendMessageBtn">Send</button>
        </div>
    </div>
</div>


<div class="modal-overlay" id="achievementsModal">
    <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
            <h3 class="modal-title">🎖️ Achievements</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div id="achievementsStats" style="margin-bottom: 20px; padding: 10px; background: #333; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px; color:white;">
                    <div>Days using Board Browser: <strong id="usageDaysCount">0</strong></div>
                    <div>Achievements unlocked: <strong id="unlockedCount">0</strong>/<span id="totalCount">0</span></div>
                </div>
                <div style="width: 100%; height: 8px; background: #444; border-radius: 4px;">
                    <div id="progressBar" style="height: 100%; background: var(--theme-color); border-radius: 4px; width: 0%;"></div>
                </div>
            </div>
            <div id="achievementsGrid" class="achievements-grid">
                <!-- Achievements will be added here dynamically -->
            </div>
        </div>
    </div>
</div>





  <!-- Modal Comemorativo -->
<div class="modal-overlay" id="celebrationModal">
  <div class="modal-content" style="max-width: 500px;">
    <div class="modal-header">
      <h3 class="modal-title">🎉 Your Progress!</h3>
      <button class="close-modal">&times;</button>
    </div>
    <div class="modal-body">
      <div id="celebrationCard" style="background: linear-gradient(135deg, #007acc 0%, #1e1e1e 100%); 
            border-radius: 10px; padding: 20px; color: white; text-align: center;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2); position: relative;">
        
        <div style="font-size: 24px; margin-bottom: 10px;">✨ Congratulations! ✨</div>
        <div style="font-size: 16px; margin-bottom: 20px;">You have been using Board Browser for <span id="usageDays">7</span> days!</div>
        
        <div style="background: rgba(255,255,255,0.1); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
          <div style="font-size: 14px; margin-bottom: 5px;">Your Progress:</div>
          <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;">
            <div style="background: rgba(255,255,255,0.2); border-radius: 50%; width: 50px; height: 50px; 
                  display: flex; align-items: center; justify-content: center; flex-direction: column;">
              <span style="font-size: 18px; font-weight: bold;" id="boardsCount">5</span>
              <span style="font-size: 10px;">Boards</span>
            </div>
            <div style="background: rgba(255,255,255,0.2); border-radius: 50%; width: 50px; height: 50px; 
                  display: flex; align-items: center; justify-content: center; flex-direction: column;">
              <span style="font-size: 18px; font-weight: bold;" id="tabsCount">12</span>
              <span style="font-size: 10px;">Webviews</span>
            </div>
            <div style="background: rgba(255,255,255,0.2); border-radius: 50%; width: 50px; height: 50px; 
                  display: flex; align-items: center; justify-content: center; flex-direction: column;">
              <span style="font-size: 18px; font-weight: bold;" id="notesCount">8</span>
              <span style="font-size: 10px;">Text Fields</span>
            </div>
          </div>
        </div>
        
        <div style="font-size: 14px; margin-bottom: 20px;">Keep exploring all the possibilities!</div>
        
        <div style="position: absolute; bottom: 10px; right: 10px; font-size: 10px; opacity: 0.7;">
          Board Browser v <span id="cardVersion">1.0</span>
        </div>
      </div>
      
      <div class="modal-footer" style="justify-content: center; margin-top: 20px;">
        <button id="saveCardBtn" class="modal-button modal-button-primary" style="margin-right: 10px;">
          <i data-lucide="download"></i> Save as PNG
        </button>

        <button id="btnAchievements" class="modal-button modal-button-secondary" title="Achievements">
            <i data-lucide="trophy"></i>
        </button>
        
      </div>
    </div>
  </div>
</div>

  <div class="modal-overlay" id="quickSearchModal">
    <div class="modal-content" style="max-width: 500px;">
        <div class="modal-header">
            <h3 class="modal-title">Quick Search</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <input type="text" id="quickSearchInput" placeholder="Enter URL or search term..." autofocus />
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button modal-button-secondary close-modal">Cancel</button>
            <button class="modal-button modal-button-primary" id="btnQuickSearchGo">Go</button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="aboutModal">
  <div class="modal-content" style="max-width: 400px;">
    <div class="modal-header">
      <h3 class="modal-title">About</h3>
      <button class="close-modal">&times;</button>
    </div>
    <div class="modal-body">
      <div style="text-align: center; margin-bottom: 20px;">
        <img src="https://boardbrowser.vercel.app/icon.png" width="20%"/>
        <h3 style="margin: 10px 0 5px 0; color: white;">Board Browser</h3>
        <p style="margin: 0; color: #aaa;">Version <span id="appVersion"></span></p>
      </div>
      <div style="border-top: 1px solid #444; padding-top: 15px;">
        <p style="text-align: center; color: #aaa; margin: 0;">
          &copy; 2025 Ricardo C Andrade<br>
          All rights reserved
        </p>
      </div>
    </div>
  </div>
</div>



  <div class="modal-overlay" id="passwordGeneratorModal">
    <div class="modal">
        <div class="modal-header">
            <h2 class="modal-title">Password Generator</h2>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>Password length:</label>
                <div class="slider-container">
                    <input type="range" min="4" max="50" value="12" class="slider" id="lengthSlider">
                    <div class="slider-value" id="lengthValue">12</div>
                </div>
            </div>

            <div class="form-group">
                <label>Include:</label>
                <div class="checkbox-group">
                    <div class="checkbox-item">
                        <input type="checkbox" id="lowercase" checked>
                        <label for="lowercase">Lowercase letters (a-z)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="uppercase" checked>
                        <label for="uppercase">Capital letters (A-Z)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="numbers" checked>
                        <label for="numbers">Numbers (0-9)</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="special" checked>
                        <label for="special">Special characters (!@#$%^&*)</label>
                    </div>
                </div>
            </div>

            <button class="generate-btn" onclick="generatePassword()">
                🔄 Generate Password
            </button>

            <div class="password-result" id="passwordResult">
                <div class="password-display">
                    <input type="text" class="password-input" id="passwordInput" readonly>
                    <button class="copy-btn" onclick="copyPassword()">📋</button>
                </div>
                <div class="copy-success" id="copySuccess">
                    ✅ Password copied successfully!
                </div>
            </div>

            <div class="error-message" id="errorMessage">
                ⚠️ Select at least one option!
            </div>
        </div>
    </div>
</div>

  <!-- Credentials Modal -->
<div class="modal-disabled" id="credentialsModal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Saved Logins</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div class="credentials-list" id="credentialsList">
                <!-- Credentials will be listed here -->
            </div>
            <div class="form-group">
                <h4>Add New Login</h4>
                <div class="credential-form">
                    <input type="text" id="credentialSite" placeholder="Website (e.g., reddit.com)" required>
                    <input type="text" id="credentialUsername" placeholder="Username or Email" required>
                    <input type="password" id="credentialPassword" placeholder="Password" required>
                    <button id="btnSaveCredential">Save</button>
                </div>
            </div>
        </div>
    </div>
</div>

  <!-- Modal de Downloads -->
    <div class="downloads-modal" id="downloadsModal">
        <div class="downloads-content">
            <div class="downloads-header">
                <h2>Downloads</h2>
                <button class="close-btn" onclick="closeDownloadsModal()">×</button>
            </div>
            <div class="downloads-list" id="downloadsList">
                <div class="empty-state">
                    <p>No downloads have finished yet.</p>
                </div>
            </div>
            <button class="clear-btn" onclick="clearDownloads()">Clear</button>
        </div>
    </div>

  <!-- Modal para renomear boards -->
  <div class="modal-disabled" id="renameModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Rename Board</h3>
        <button class="close-modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="renameBoardSelect">Select the Board:</label>
          <select id="renameBoardSelect" class="form-control"></select>
        </div>
        <div class="form-group">
          <label for="renameBoardInput">New Name:</label>
          <input type="text" id="renameBoardInput" class="form-control" placeholder="Digite o novo nome">
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-button modal-button-secondary close-modal">Cancel</button>
        <button class="modal-button modal-button-primary" id="btnSaveRename">Save</button>
      </div>
    </div>
  </div>

  <div id="context-menu">
    <button id="ctx-create-tab">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-earth-icon lucide-earth"><path d="M21.54 15H17a2 2 0 0 0-2 2v4.54"/><path d="M7 3.34V5a3 3 0 0 0 3 3a2 2 0 0 1 2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.1.9-2 2-2h3.17"/><path d="M11 21.95V18a2 2 0 0 0-2-2a2 2 0 0 1-2-2v-1a2 2 0 0 0-2-2H2.05"/><circle cx="12" cy="12" r="10"/></svg>
        New Webview</button>
    <button id="ctx-create-textfield">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-type-icon lucide-file-type"><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M9 13v-1h6v1"/><path d="M12 12v6"/><path d="M11 18h2"/></svg>
        Text field</button>
    <button id="ctx-create-list">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-list-checks-icon lucide-list-checks"><path d="m3 17 2 2 4-4"/><path d="m3 7 2 2 4-4"/><path d="M13 6h8"/><path d="M13 12h8"/><path d="M13 18h8"/></svg>
        List</button>
    <button id="ctx-change-theme">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-palette-icon lucide-palette"><path d="M12 22a1 1 0 0 1 0-20 10 9 0 0 1 10 9 5 5 0 0 1-5 5h-2.25a1.75 1.75 0 0 0-1.4 2.8l.3.4a1.75 1.75 0 0 1-1.4 2.8z"/><circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/><circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/><circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/><circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/></svg>
        Change Theme Color</button>
    <button id="ctx-zoom">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zoom-in-icon lucide-zoom-in"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>
        Zoom</button>
  </div>

  <!-- Modal para histórico -->
<div class="modal-disabled" id="historyModal">
    <div class="modal-content">
        <div class="modal-header">
            <h3 class="modal-title">Browsing History</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <input type="text" id="historySearch" class="form-control" placeholder="Search history...">
            </div>
            <div class="history-list" id="historyList">
                <!-- Os itens de histórico serão adicionados aqui dinamicamente -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button modal-button-secondary" id="btnClearHistoryModal">Clear History</button>
        </div>
    </div>
</div>

<!-- Modal para seleção de cor de tema -->
<div class="modal-disabled" id="themeColorModal">
    <div class="modal-content" style="max-width: 300px;">
        <div class="modal-header">
            <h3 class="modal-title">Select Theme Color</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <div id="color-picker-container">
                <div id="color-spectrum"></div>
                <div id="color-selector"></div>
            </div>
            <div id="selected-color-preview"></div>
            <div class="form-group" style="margin-top: 15px;">
                <label for="theme-color-hex">HEX:</label>
                <input type="text" id="theme-color-hex" readonly>
            </div>
        </div>
        <div class="modal-footer">
            <button class="modal-button modal-button-secondary close-modal">Cancel</button>
            <button class="modal-button modal-button-secondary" id="btnResetThemeColor">Reset to Default</button>
            <button class="modal-button modal-button-primary" id="btnSaveThemeColor">Apply</button>
        </div>
    </div>
</div>

  <!-- Modal para configurações -->
  <div class="modal-disabled" id="settingsModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3 class="modal-title">Settings</h3>
      <button class="close-modal">&times;</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label for="startPageInput">StartPage Webview:</label>
        <input type="text" id="startPageInput" placeholder="https://example.com" />
      </div>
      <div class="form-group">
        <label for="searchEngineSelect">Search Engine Default:</label>
        <select id="searchEngineSelect">
          <option value="google">Google</option>
          <option value="duckduckgo">DuckDuckGo</option>
          <option value="bing">Bing</option>
          <option value="chatgpt">ChatGPT</option>
          <option value="perplexity">Perplexity</option>

        </select>
      </div>

      <div class="form-group">
        <button class="modal-button modal-button-secondary" id="btnClearHistory">Clear Browsing History</button>
      </div>



    </div>
    <div class="modal-footer">
      <button class="modal-button modal-button-secondary close-modal">Cancel</button>
      <button class="modal-button modal-button-primary" id="btnSaveSettings">Save</button>
    </div>
  </div>
</div>

  <!-- Modal para importar boards -->
  <div class="modal-disabled" id="importModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Import Boards</h3>
        <button class="close-modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Select the JSON file:</label>
          <div class="file-input-container">
            <div class="file-input-button">Select File</div>
            <input type="file" id="importFileInput" class="file-input" accept=".json">
          </div>
          <div id="importFileName" class="file-name">No selected files</div>
        </div>
        <div class="form-group">
          <label>
            <input type="checkbox" id="importOverwriteCheckbox"> Replace existing boards?
          </label>
        </div>
      </div>
      <div class="modal-footer">
        <button class="modal-button modal-button-secondary close-modal">Cancel</button>
        <button class="modal-button modal-button-primary" id="btnImportConfirm" disabled>Import</button>
      </div>
    </div>
  </div>

  <!-- Modal de favoritos -->
  <div class="modal-disabled" id="favoritesModal">
    <div class="modal-content" id="favorites-modal">
      <div class="modal-header">
        <h3 class="modal-title">Favorites</h3>
        <button class="close-modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="favorites-grid" id="favoritesGrid">
          <!-- Os favoritos serão adicionados aqui dinamicamente -->
        </div>
      </div>
    </div>
  </div>

<script>
let VERSION = 'Beta 3.0'

const fs = require('fs');
const path = require('path');

let apiKey = '';

try {
  const configPath = path.join(__dirname, '/src/config.json');
  const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
  apiKey = config.apiKey || '';
} catch (error) {
  console.error('Error loading API key:', error);
  // Você pode querer mostrar um aviso ao usuário ou usar um fallback
}


let firstUseDate = localStorage.getItem('firstUseDate');
if (!firstUseDate) {
  firstUseDate = new Date().toISOString();
  localStorage.setItem('firstUseDate', firstUseDate);
}


const desktopContainer = document.getElementById('desktop-container');
const desktop = document.getElementById('desktop');
const btnNewTab = document.getElementById('btnNewTab');
const dropdownMenu = document.getElementById('dropdown-menu');
const btnCreateTab = document.getElementById('btnCreateTab');
const btnCreataTabAnon = document.getElementById('btnCreateTabAnon');
const btnCreateTextField = document.getElementById('btnCreateTextField');
const btnCreateList = document.getElementById('btnCreateList');
const btnCreateBoard = document.getElementById('btnCreateBoard');
const boardsContainer = document.getElementById('boards-container');
const btnFavorites = document.getElementById('btnFavorites');
const favoritesModal = document.getElementById('favoritesModal');
const favoritesGrid = document.getElementById('favoritesGrid');
const btnMoreOptions = document.getElementById('btnMoreOptions');
const moreOptionsMenu = document.getElementById('more-options-menu');
const btnExportBoards = document.getElementById('btnExportBoards');
const btnImportBoards = document.getElementById('btnImportBoards');
const btnRenameBoards = document.getElementById('btnRenameBoards');
const renameModal = document.getElementById('renameModal');
const renameBoardSelect = document.getElementById('renameBoardSelect');
const renameBoardInput = document.getElementById('renameBoardInput');
const btnSaveRename = document.getElementById('btnSaveRename');
const closeModalButtons = document.querySelectorAll('.close-modal');
const importModal = document.getElementById('importModal');
const importFileInput = document.getElementById('importFileInput');
const importFileName = document.getElementById('importFileName');
const importOverwriteCheckbox = document.getElementById('importOverwriteCheckbox');
const btnImportConfirm = document.getElementById('btnImportConfirm');
const zoomAreaTrigger = document.getElementById('zoom-area-trigger');
const zoomControls = document.getElementById('zoom-controls');
const zoomOutBtn = document.getElementById('zoom-out');
const zoomInBtn = document.getElementById('zoom-in');
const zoomSlider = document.getElementById('zoom-slider');
const zoomLevel = document.getElementById('zoom-level');
const resetZoomBtn = document.getElementById('reset-zoom');
const btnMoveMode = document.getElementById('btnMoveMode');
const btnBrush = document.getElementById('btnBrush');
const btnEraser = document.getElementById('btnEraser');
const btnClean = document.getElementById('btnClean');
const colorPickerMenu = document.getElementById('color-picker-menu');
const colorOptions = document.querySelectorAll('.color-option');
const brushSizeControl = document.getElementById('brush-size-control');
const brushSizeValue = document.getElementById('brush-size-value');
const drawingCanvas = document.getElementById('drawing-canvas');
const ctx = drawingCanvas.getContext('2d');

const btnSettings = document.getElementById('btnSettings');
const settingsModal = document.getElementById('settingsModal');
const startPageInput = document.getElementById('startPageInput');
const searchEngineSelect = document.getElementById('searchEngineSelect');
const btnSaveSettings = document.getElementById('btnSaveSettings');
const btnClearHistory = document.getElementById('btnClearHistory');

const btnHistory = document.getElementById('btnHistory');
const historyModal = document.getElementById('historyModal');
const historyList = document.getElementById('historyList');
const btnClearHistoryModal = document.getElementById('btnClearHistoryModal');
const historySearch = document.getElementById('historySearch');

const contextMenu = document.getElementById('context-menu');
const ctxCreateTab = document.getElementById('ctx-create-tab');
const ctxCreateTextField = document.getElementById('ctx-create-textfield');
const ctxCreateList = document.getElementById('ctx-create-list');
const ctxChangeTheme = document.getElementById("ctx-change-theme");
const ctxResetTheme = document.getElementById("btnResetThemeColor");
const ctxZoom = document.getElementById("ctx-zoom");

let isMoveModeActive = false;
var isCopyModeActive = false;
var isZoomEnable = false;
let currentThemeColor = localStorage.getItem('themeColor') || '#007acc';

let savedCredentials = JSON.parse(localStorage.getItem('savedCredentials')) || [];
const credentialsModal = document.getElementById('credentialsModal');
const credentialsList = document.getElementById('credentialsList');
const credentialSiteInput = document.getElementById('credentialSite');
const credentialUsernameInput = document.getElementById('credentialUsername');
const credentialPasswordInput = document.getElementById('credentialPassword');
const btnSaveCredential = document.getElementById('btnSaveCredential');

const btnPasswordsGenerator = document.getElementById("btnPasswordsGenerator");
const passwordGeneratorModal = document.getElementById("passwordGeneratorModal");

const btnInputAI = document.createElement('button');


const btnCredentials = document.createElement('button');


const quickSearchModal = document.getElementById('quickSearchModal');
const quickSearchInput = document.getElementById('quickSearchInput');
const btnQuickSearchGo = document.getElementById('btnQuickSearchGo');
const btnQuickSearch = document.getElementById('btnQuickSearch');
const btnAbout = document.getElementById('btnAbout');
const btnCard = document.getElementById('btnCard');
const saveCardBtn = document.getElementById('saveCardBtn');

const exportChatBtn = document.getElementsByClassName("export-chat")[0];
let selectedIcon = localStorage.getItem('appIcon') || 'default.png';


const iconModal = document.getElementById('iconModal');
const iconsGrid = document.getElementById('iconsGrid');
const availableIcons = [
    'default.png',
    'oldschool.png',
    'variation.png',
    'darkblue.png'
];


let chatInputDraggable = null;


function loadIconModal() {
    iconsGrid.innerHTML = '';
    
    availableIcons.forEach(icon => {
        const iconOption = document.createElement('div');
        iconOption.classList.add('icon-option');
        if (icon === selectedIcon) {
            iconOption.classList.add('selected');
        }
        iconOption.dataset.icon = icon;
        
        iconOption.innerHTML = `
            <img src="icons/${icon}" class="icon-preview" alt="${icon}">
            <div class="icon-name">${icon.replace('.png', '')}</div>
        `;
        
        iconOption.addEventListener('click', () => {
            // Remove a seleção de todos os ícones
            document.querySelectorAll('.icon-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            // Adiciona seleção ao ícone clicado
            iconOption.classList.add('selected');
            selectedIcon = icon;
            
            // Salva no localStorage
            localStorage.setItem('appIcon', icon);
            
            // Atualiza o ícone da janela
            updateAppIcon(icon);
            
            // Fecha o modal após 1 segundo (opcional)
            setTimeout(() => {
                iconModal.style.display = 'none';
            }, 1000);
        });
        
        iconsGrid.appendChild(iconOption);
    });
}

// Função para atualizar o ícone do aplicativo
function updateAppIcon(iconName) {
    const { ipcRenderer } = require('electron');
    ipcRenderer.send('change-app-icon', `icons/${iconName}`);
}



// Fechar modal ao clicar no overlay
iconModal.addEventListener('click', (e) => {
    if (e.target === iconModal) {
        iconModal.style.display = 'none';
    }
});

// Fechar modal com o botão de fechar
iconModal.querySelector('.close-modal').addEventListener('click', () => {
    iconModal.style.display = 'none';
});


exportChatBtn.addEventListener('click',() =>{
    var chatMessages = document.getElementById('chatMessages');
    var divs = chatMessages.getElementsByTagName("div");
    var texto = "";
    for(var i = 0; i < divs.length; i++){
        if(divs[i].classList.contains("ai-message")){
            texto += "[AI]\n";
        }
        else{
            texto += "[USER]\n";
        }
        texto += divs[i].textContent + "\n\n";
    }
    

    createTextField(null,null,texto);
});



function initiateButtons(){
    btnInputAI.id = 'btnInputAI';
    btnInputAI.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-brain-icon lucide-brain"><path d="M12 18V5"/><path d="M15 13a4.17 4.17 0 0 1-3-4 4.17 4.17 0 0 1-3 4"/><path d="M17.598 6.5A3 3 0 1 0 12 5a3 3 0 1 0-5.598 1.5"/><path d="M17.997 5.125a4 4 0 0 1 2.526 5.77"/><path d="M18 18a4 4 0 0 0 2-7.464"/><path d="M19.967 17.483A4 4 0 1 1 12 18a4 4 0 1 1-7.967-.517"/><path d="M6 18a4 4 0 0 1-2-7.464"/><path d="M6.003 5.125a4 4 0 0 0-2.526 5.77"/></svg> AI';
    
    if(defaultAIOption === 'AIenabled'){
        dropdownMenu.insertBefore(btnInputAI,btnQuickSearch);
    }
    

    btnCredentials.id = 'btnCredentials';
    btnCredentials.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-key-round-icon lucide-key-round"><path d="M2.586 17.414A2 2 0 0 0 2 18.828V21a1 1 0 0 0 1 1h3a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h1a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1h.172a2 2 0 0 0 1.414-.586l.814-.814a6.5 6.5 0 1 0-4-4z"/><circle cx="16.5" cy="7.5" r=".5" fill="currentColor"/></svg> Saved Logins';
    moreOptionsMenu.insertBefore(btnCredentials, btnRenameBoards);
}

function removeElementsByClass(className) {
    const elements = document.querySelectorAll(`.${className}`);
    elements.forEach(element => element.remove());
}


function createChatInput() {
    if (chatInputDraggable) {
        // Animação de explosão ao remover
        const chatRect = chatInputDraggable.getBoundingClientRect();
        const centerX = chatRect.left + chatRect.width / 2;
        const centerY = chatRect.top + chatRect.height / 2;
        
        // Aplica animação de explosão
        chatInputDraggable.style.transformOrigin = 'center';
        chatInputDraggable.style.animation = 'explode 0.3s ease-out forwards';
        
        // Cria partículas de fumaça
        for (let i = 0; i < 10; i++) {
            createSmokeParticle(centerX, centerY);
        }
        
        // Remove após a animação
        setTimeout(() => {
            removeElementsByClass("chat-input-container");
            chatInputDraggable = null;
        }, 300);
        return;
    }
    
    chatInputDraggable = document.createElement('div');
    chatInputDraggable.className = 'chat-input-container';
    chatInputDraggable.innerHTML = `
        <input type="text" placeholder="Ask AI anything..." id="aiChatInput">
        <button><i data-lucide="send"></i></button>
    `;
    
    // Posição inicial com animação de entrada
    chatInputDraggable.style.left = '20px';
    chatInputDraggable.style.top = '60px';

    chatInputDraggable.style.opacity = '0';
    chatInputDraggable.style.transform = 'scale(0.5)';
    chatInputDraggable.style.animation = 'fadeInScale 0.3s ease-out forwards';

    document.body.appendChild(chatInputDraggable);
    lucide.createIcons();
    
    // Tornar arrastável
    makeDraggable2(chatInputDraggable);
    
    // Evento para abrir o chat ao pressionar Enter
    const input = chatInputDraggable.querySelector('input');
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && input.value.trim()) {
            openChatModal(input.value.trim());
            input.value = '';
        }
    });
    
    // Evento para o botão
    chatInputDraggable.querySelector('button').addEventListener('click', () => {
        if (input.value.trim()) {
            openChatModal(input.value.trim());
            input.value = '';
        }
    });
}

// Função para abrir o modal de chat
function openChatModal(initialMessage = '') {
    const chatModal = document.getElementById('chatModal');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    
    // Reset do modal
    chatMessages.innerHTML = '';
    chatInput.value = '';
    
    chatModal.style.display = 'flex';
    
    if (initialMessage) {
        addMessage(initialMessage, 'user');
        sendToGroq(initialMessage);
    }
    
    // Focar no input automaticamente
    setTimeout(() => {
        chatInput.focus();
    }, 100);
    
    // Configura o auto-scroll quando novas mensagens chegam
    const observer = new MutationObserver(() => {
        const isScrolledToBottom = chatMessages.scrollHeight - chatMessages.clientHeight <= chatMessages.scrollTop + 50;
        if (isScrolledToBottom) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    });
    
    observer.observe(chatMessages, { childList: true });
    
    // Fechar modal
    document.querySelector('.close-chat').addEventListener('click', () => {
        observer.disconnect();
        chatModal.style.display = 'none';
    });
    
    // Enviar mensagem
    function sendMessage() {
        const message = chatInput.value.trim();
        if (message) {
            addMessage(message, 'user');
            chatInput.value = '';
            sendToGroq(message);
        }
    }
    
    document.getElementById('sendMessageBtn').addEventListener('click', sendMessage);
    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
    });
}

// Adicionar mensagem ao chat
function addMessage(text, sender) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    
    // Processa quebras de linha e URLs
    const processedText = text
        .replace(/\n/g, '<br>')
        .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
    
    messageDiv.innerHTML = processedText;
    chatMessages.appendChild(messageDiv);
    
    // Scroll automático apenas se já estiver no final
    const isScrolledToBottom = chatMessages.scrollHeight - chatMessages.clientHeight <= chatMessages.scrollTop + 1;
    if (isScrolledToBottom) {
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
}

// Enviar para a API da Groq
async function sendToGroq(message) {
    try {
        
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: 'llama-3.3-70b-versatile', // ou outro modelo disponível
                messages: [{ role: 'user', content: message }],
                temperature: 0.7
            })
        });
        
        const data = await response.json();
        if (data.choices && data.choices[0].message) {
            addMessage(data.choices[0].message.content, 'ai');
        } else {
            addMessage("Sorry, I couldn't process your request.", 'ai');
        }
    } catch (error) {
        console.error('Error calling Groq API:', error);
        addMessage("Sorry, there was an error processing your request.", 'ai');
    }
}

// SOLUÇÃO 1: Usar uma área específica para arrasto (não o input)
function makeDraggable2(element) {

    

    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    
    // Procura por um elemento com classe 'drag-handle' ou usa o próprio elemento
    let dragHandle = element.querySelector('.drag-handle') || element;
    
    // Se o dragHandle for um input, usa o elemento pai
    if (dragHandle.tagName === 'INPUT') {
        dragHandle = element;
    }
    
    dragHandle.onmousedown = dragMouseDown;

    function dragMouseDown(e) {
        if(!btnMoveMode.classList.contains('active')) {
            return; // Se não tem a classe active, não permite movimentação
        }

        // Se o clique foi em um elemento interativo, não arrastamos
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || 
            e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
            return;
        }
        
        e = e || window.event;
        e.preventDefault();
        
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        document.onmousemove = elementDrag;
    }

    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
        document.onmouseup = null;
        document.onmousemove = null;
    }
}

// Definição das conquistas
const achievements = [
    { id: '3days', title: 'First Steps', description: 'Use Board Browser for 3 days', icon: '🥉', daysRequired: 3 },
    { id: '7days', title: 'Weekly User', description: 'Use Board Browser for 1 week', icon: '🏆', daysRequired: 7 },
    { id: '15days', title: 'Fortnight Fan', description: 'Use Board Browser for 15 days', icon: '🎖️', daysRequired: 15 },
    { id: '30days', title: 'Monthly Master', description: 'Use Board Browser for 1 month', icon: '📅', daysRequired: 30 },
    { id: '90days', title: 'Quarterly Queen', description: 'Use Board Browser for 3 months', icon: '👑', daysRequired: 90 },
    { id: '180days', title: 'Half-Year Hero', description: 'Use Board Browser for 6 months', icon: '🦸', daysRequired: 180 },
    { id: '365days', title: 'Annual Ace', description: 'Use Board Browser for 1 year', icon: '🌟', daysRequired: 365 },
    { id: '730days', title: 'Biennial Boss', description: 'Use Board Browser for 2 years', icon: '💎', daysRequired: 730 }
];

// Variável para armazenar conquistas desbloqueadas
let unlockedAchievements = JSON.parse(localStorage.getItem('achievements')) || {};

// Botão e modal de conquistas
const btnAchievements = document.getElementById('btnAchievements');
const achievementsModal = document.getElementById('achievementsModal');
const achievementsGrid = document.getElementById('achievementsGrid');

// Mostrar modal de conquistas
btnAchievements.addEventListener('click', () => {
    showAchievementsModal();
});

function showAchievementsModal() {
    updateAchievementsDisplay();
    achievementsModal.style.display = 'flex';
}

function updateAchievementsDisplay() {
    const now = new Date();
    const firstDate = new Date(firstUseDate);
    const diffTime = Math.abs(now - firstDate);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    // Atualiza estatísticas
    document.getElementById('usageDaysCount').textContent = diffDays;
    document.getElementById('totalCount').textContent = achievements.length;
    
    // Verifica e desbloqueia conquistas
    let unlockedCount = 0;
    achievements.forEach(achievement => {
        if (diffDays >= achievement.daysRequired && !unlockedAchievements[achievement.id]) {
            unlockedAchievements[achievement.id] = new Date().toISOString();
            // Mostrar notificação quando uma nova conquista é desbloqueada
            
        }
        
        if (unlockedAchievements[achievement.id]) {
            unlockedCount++;
        }
    });
    
    // Salva conquistas desbloqueadas
    localStorage.setItem('achievements', JSON.stringify(unlockedAchievements));
    document.getElementById('unlockedCount').textContent = unlockedCount;
    
    // Atualiza barra de progresso
    const progress = (unlockedCount / achievements.length) * 100;
    document.getElementById('progressBar').style.width = `${progress}%`;
    
    // Limpa o grid
    achievementsGrid.innerHTML = '';
    
    // Adiciona as conquistas ao grid
    achievements.forEach(achievement => {
        const isUnlocked = diffDays >= achievement.daysRequired;
        const achievementDate = unlockedAchievements[achievement.id] ? 
            new Date(unlockedAchievements[achievement.id]).toLocaleDateString() : '';
        
        const achievementItem = document.createElement('div');
        achievementItem.className = `achievement-item ${isUnlocked ? 'unlocked' : 'locked'}`;
        achievementItem.innerHTML = `
            <div class="achievement-icon">${achievement.icon}</div>
            <div class="achievement-title">${achievement.title}</div>
            <div class="achievement-desc">${achievement.description}</div>
            ${isUnlocked ? 
                `<div class="achievement-date">Unlocked: ${achievementDate}</div>` : 
                `<div class="achievement-locked" title="Locked"><i data-lucide="lock"></i></div>`}
        `;
        
        achievementsGrid.appendChild(achievementItem);
    });
    
    // Atualiza ícones Lucide
    lucide.createIcons();
}


// Verifica conquistas periodicamente
setInterval(() => {
    if (achievementsModal.style.display === 'flex') {
        updateAchievementsDisplay();
    }
}, 1000 * 60); // Verifica a cada minuto


const firstDate = new Date(firstUseDate);
const now = new Date();
const diffTime = Math.abs(now - firstDate);
const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

if (diffDays >= 7 && !localStorage.getItem('celebrationShown')) {
  setTimeout(showCelebrationModal, 2000);
  localStorage.setItem('celebrationShown', 'true');
}


btnCard.addEventListener('click', function(){
    if(diffDays >= 2){
        showCelebrationModal();
    }
    else{
        showMessage('You are not a member yet!\nUse this browser for more than 24 hours to unlock the member card.');
    }
    
});

function showCelebrationModal() {
  const now = new Date();
  const firstDate = new Date(firstUseDate);
  const diffTime = Math.abs(now - firstDate);
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
  
  // Atualiza os dados do card
  document.getElementById('usageDays').textContent = diffDays;
  document.getElementById('boardsCount').textContent = Object.keys(boards).length;
  
  let totalTabs = 0;
  Object.values(boards).forEach(board => {
    totalTabs += board.tabs.length;
  });
  document.getElementById('tabsCount').textContent = totalTabs;
  
  let totalNotes = 0;
  Object.values(boards).forEach(board => {
    totalNotes += board.textFields.length + board.lists.length;
  });
  document.getElementById('notesCount').textContent = totalNotes;
  
  // Obtém a versão do app
  //const { app } = require('electron').remote;
  document.getElementById('cardVersion').textContent = VERSION; //app.getVersion();
  
  // Mostra o modal
  document.getElementById('celebrationModal').style.display = 'flex';
}


saveCardBtn.addEventListener('click', saveCardAsPNG);




function saveCardAsPNG() {
  const card = document.getElementById('celebrationCard');
  const { ipcRenderer } = require('electron');
  
  // Usamos html2canvas para capturar o card
  const html2canvas = require('html2canvas');
  
  html2canvas(card, {
    backgroundColor: null,
    scale: 2 // Melhor qualidade
  }).then(canvas => {
    const image = canvas.toDataURL('image/png');
    ipcRenderer.send('save-image', image);
  });
}


btnAbout.addEventListener('click', function(){
    document.getElementById('appVersion').textContent = VERSION;
    document.getElementById('aboutModal').style.display = 'flex';
    moreOptionsMenu.style.display = 'none';
    
});

btnQuickSearch.addEventListener('click', function(){
    openQuickSearchModal();
});

// Função para verificar se uma string parece uma URL
function isLikelyUrl(text) {
    const urlPattern = /^(https?:\/\/)?([\w-]+\.)+[\w-]+(\/[\w- .\/?%&=]*)?$/i;
    const tldPattern = /\.(com|net|org|io|gov|edu|co|br|uk|de|fr|es|it|ru|ca|au|in|jp|cn|us|info|biz|xyz|me|tv|cc|ws|eu|mobi|app|dev|online|store|shop|blog|tech|site|website|space|digital|live|life|world|club|fun|top|pro|asia|africa|europe|northamerica|southamerica|australia|antarctica|arctic|global|local|dev|test|example)$/i;
    
    return urlPattern.test(text) || tldPattern.test(text.split(' ')[0]);
}

// Função para abrir o modal de pesquisa rápida
function openQuickSearchModal() {
    quickSearchModal.style.display = 'flex';
    quickSearchInput.value = '';
    quickSearchInput.focus();
}

// Função para processar a pesquisa/URL
function processQuickSearch() {
    const input = quickSearchInput.value.trim();
    if (!input) return;

    let url;
    
    if (isLikelyUrl(input)) {
        // Se parece uma URL, adiciona http:// se não tiver
        url = input.startsWith('http://') || input.startsWith('https://') ? 
              input : `https://${input}`;
    } else {
        // Se não parece URL, faz uma pesquisa
        const searchEngine = defaultSearchEngine || 'google';
        switch(searchEngine) {
            case 'duckduckgo':
                url = `https://duckduckgo.com/?q=${encodeURIComponent(input)}`;
                break;
            case 'bing':
                url = `https://www.bing.com/search?q=${encodeURIComponent(input)}`;
                break;
            case 'perplexity':
                url = `https://www.perplexity.ai/?q=${encodeURIComponent(input)}`;
                break;
            case 'chatgpt':
                url = `https://chat.openai.com/?q=${encodeURIComponent(input)}`;
                break;
            case 'google':
            default:
                url = `https://www.google.com/search?q=${encodeURIComponent(input)}`;
        }
    }

    createTab(url);
    quickSearchModal.style.display = 'none';
}

// Atalho Ctrl+Q para abrir o modal de pesquisa rápida
document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key.toLowerCase() === 'q') {
        e.preventDefault();
        openQuickSearchModal();
    }
});

// Event listeners para o modal
btnQuickSearchGo.addEventListener('click', processQuickSearch);
quickSearchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        processQuickSearch();
    }
});

// Fechar modal ao clicar fora
quickSearchModal.addEventListener('click', (e) => {
    if (e.target === quickSearchModal) {
        quickSearchModal.style.display = 'none';
    }
});





function showConfirm(message) {
    return new Promise((resolve) => {
        // Criar overlay de fundo
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        overlay.style.zIndex = '99999';
        overlay.style.display = 'flex';
        overlay.style.alignItems = 'center';
        overlay.style.justifyContent = 'center';

        // Criar modal
        const modal = document.createElement('div');
        modal.style.background = '#333';
        modal.style.color = 'white';
        modal.style.padding = '30px';
        modal.style.borderRadius = '12px';
        modal.style.minWidth = '300px';
        modal.style.maxWidth = '500px';
        modal.style.textAlign = 'center';
        modal.style.boxShadow = '0 10px 30px rgba(0, 0, 0, 0.3)';
        modal.style.animation = 'modalFadeIn 0.2s ease-out';

        // Adicionar CSS da animação
        if (!document.getElementById('modal-styles')) {
            const style = document.createElement('style');
            style.id = 'modal-styles';
            style.textContent = `
                @keyframes modalFadeIn {
                    from {
                        opacity: 0;
                        transform: scale(0.9);
                    }
                    to {
                        opacity: 1;
                        transform: scale(1);
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Texto da mensagem
        const messageElement = document.createElement('p');
        messageElement.style.margin = '0 0 25px 0';
        messageElement.style.fontSize = '16px';
        messageElement.style.lineHeight = '1.5';
        messageElement.innerText = message;

        // Container dos botões
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '15px';
        buttonContainer.style.justifyContent = 'center';

        // Botão Cancelar
        const cancelButton = document.createElement('button');
        cancelButton.innerText = 'Cancel';
        cancelButton.style.padding = '12px 24px';
        cancelButton.style.border = 'none';
        cancelButton.style.borderRadius = '6px';
        cancelButton.style.background = '#666';
        cancelButton.style.color = 'white';
        cancelButton.style.cursor = 'pointer';
        cancelButton.style.fontSize = '14px';
        cancelButton.style.fontWeight = '500';
        cancelButton.style.transition = 'background 0.2s';
        
        cancelButton.onmouseover = () => cancelButton.style.background = '#777';
        cancelButton.onmouseout = () => cancelButton.style.background = '#666';
        
        cancelButton.onclick = () => {
            overlay.remove();
            resolve(false);
        };

        // Botão Confirmar
        const confirmButton = document.createElement('button');
        confirmButton.innerText = 'Confirm';
        confirmButton.style.padding = '12px 24px';
        confirmButton.style.border = 'none';
        confirmButton.style.borderRadius = '6px';
        confirmButton.style.background = '#e74c3c';
        confirmButton.style.color = 'white';
        confirmButton.style.cursor = 'pointer';
        confirmButton.style.fontSize = '14px';
        confirmButton.style.fontWeight = '500';
        confirmButton.style.transition = 'background 0.2s';
        
        confirmButton.onmouseover = () => confirmButton.style.background = '#c0392b';
        confirmButton.onmouseout = () => confirmButton.style.background = '#e74c3c';
        
        confirmButton.onclick = () => {
            overlay.remove();
            resolve(true);
        };

        // Fechar ao clicar no overlay
        overlay.onclick = (e) => {
            if (e.target === overlay) {
                overlay.remove();
                resolve(false);
            }
        };

        // Suporte a teclas ESC e Enter
        const keyHandler = (e) => {
            if (e.key === 'Escape') {
                overlay.remove();
                document.removeEventListener('keydown', keyHandler);
                resolve(false);
            } else if (e.key === 'Enter') {
                overlay.remove();
                document.removeEventListener('keydown', keyHandler);
                resolve(true);
            }
        };
        document.addEventListener('keydown', keyHandler);

        // Montar o modal
        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(confirmButton);
        modal.appendChild(messageElement);
        modal.appendChild(buttonContainer);
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        // Focar no botão cancelar por padrão
        cancelButton.focus();
    });
}

ctxZoom.addEventListener('click',function(){
    showZoom();
});


function showZoom(){
    if(isZoomEnable == false){
        isZoomEnable = true;
        zoomControls.classList.add('visible');
    }
    else{
        isZoomEnable = false;
        zoomControls.classList.remove('visible');
    }
}



if (btnPasswordsGenerator) {
    btnPasswordsGenerator.addEventListener('click', (e) => {
        e.preventDefault();
        showPasswordsGeneratorModal();
        // Fechar o menu de mais opções se estiver aberto
        if (moreOptionsMenu) {
            moreOptionsMenu.style.display = 'none';
        }
    });
}

btnInputAI.addEventListener('click', () => {
    createChatInput();
});

btnCredentials.addEventListener('click', () => {
    showCredentialsModal();
    moreOptionsMenu.style.display = 'none';
});

function showPasswordsGeneratorModal() {
    const modal = document.getElementById('passwordGeneratorModal');
    if (modal) {
        modal.style.display = 'flex';
        // Resetar valores para padrão
        document.getElementById('lengthSlider').value = 12;
        document.getElementById('lengthValue').textContent = '12';
        document.getElementById('passwordInput').value = '';
        document.getElementById('copySuccess').style.display = 'none';
        document.getElementById('errorMessage').style.display = 'none';
    }
}



function generatePassword() {
    const length = parseInt(document.getElementById('lengthSlider').value);
    const lowercase = document.getElementById('lowercase').checked;
    const uppercase = document.getElementById('uppercase').checked;
    const numbers = document.getElementById('numbers').checked;
    const special = document.getElementById('special').checked;
    
    const errorMessage = document.getElementById('errorMessage');
    const passwordInput = document.getElementById('passwordInput');
    
    // Esconder mensagem de erro
    errorMessage.style.display = 'none';
    
    // Verificar se pelo menos uma opção foi selecionada
    if (!lowercase && !uppercase && !numbers && !special) {
        errorMessage.style.display = 'block';
        return;
    }
    
    // Criar conjunto de caracteres
    let charset = '';
    if (lowercase) charset += 'abcdefghijklmnopqrstuvwxyz';
    if (uppercase) charset += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    if (numbers) charset += '0123456789';
    if (special) charset += '!@#$%^&*()_+-=[]{}|;:,.<>?';
    
    // Gerar senha
    let password = '';
    for (let i = 0; i < length; i++) {
        password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    
    passwordInput.value = password;
}

function copyPassword() {
    const passwordInput = document.getElementById('passwordInput');
    const copySuccess = document.getElementById('copySuccess');
    
    if (passwordInput.value) {
        // Método moderno para copiar
        if (navigator.clipboard) {
            navigator.clipboard.writeText(passwordInput.value).then(() => {
                showCopySuccess();
            }).catch(() => {
                // Fallback para método antigo
                fallbackCopyTextToClipboard(passwordInput.value);
            });
        } else {
            // Fallback para navegadores mais antigos
            fallbackCopyTextToClipboard(passwordInput.value);
        }
    }
}

function fallbackCopyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";  // Evita rolagem para o elemento
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
        const successful = document.execCommand('copy');
        if (successful) {
            console.log('Fallback copy succeeded');
            window.postMessage({ type: 'copyCompleted' }, '*');
        } else {
            console.error('Fallback copy failed');
        }
    } catch (err) {
        console.error('Fallback copy error:', err);
    }

    document.body.removeChild(textArea);
}

function showCopySuccess() {
    const copySuccess = document.getElementById('copySuccess');
    copySuccess.style.display = 'block';
    setTimeout(() => {
        copySuccess.style.display = 'none';
    }, 2000);
}
document.addEventListener('DOMContentLoaded', function() {
    // Slider de comprimento
    const lengthSlider = document.getElementById('lengthSlider');
    const lengthValue = document.getElementById('lengthValue');
    
    if (lengthSlider && lengthValue) {
        lengthSlider.addEventListener('input', function() {
            lengthValue.textContent = this.value;
        });
    }
    
    // Fechar modal
    const closeModalBtn = document.querySelector('#passwordGeneratorModal .close-modal');
    if (closeModalBtn) {
        closeModalBtn.addEventListener('click', function() {
            passwordGeneratorModal.style.display = 'none';
        });
    }
    
    // Fechar modal clicando fora
    if (passwordGeneratorModal) {
        passwordGeneratorModal.addEventListener('click', function(e) {
            if (e.target === this) {
                this.style.display = 'none';
            }
        });
    }
    
    // Botão de gerar senha
    const generateBtn = document.querySelector('#passwordGeneratorModal .generate-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', generatePassword);
    }
    
    // Botão de copiar
    const copyBtn = document.querySelector('#passwordGeneratorModal .copy-btn');
    if (copyBtn) {
        copyBtn.addEventListener('click', copyPassword);
    }

    
});

function checkModalStyles() {
    const modal = document.getElementById('passwordGeneratorModal');
    if (modal) {
        const styles = window.getComputedStyle(modal);
        console.log('Modal display:', styles.display);
        console.log('Modal position:', styles.position);
        console.log('Modal z-index:', styles.zIndex);
    }
}




function showCredentialsModal() {
    updateCredentialsList();
    credentialsModal.style.display = 'flex';
}

function updateCredentialsList() {
    credentialsList.innerHTML = '';
    
    if (savedCredentials.length === 0) {
        credentialsList.innerHTML = '<div class="no-credentials">No saved logins yet.</div>';
        return;
    }
    
    savedCredentials.forEach((credential, index) => {
        const item = document.createElement('div');
        item.classList.add('credential-item');
        
        item.innerHTML = `
            <div class="credential-item-info">
                <strong>${credential.site}</strong><br>
                <small>${credential.username}</small>
            </div>
            <div class="credential-item-actions">
                <button class="btn-use-credential" data-index="${index}" title="Use this login">Use</button>
                <button class="btn-show-credential" data-index="${index}" title="Show">Show</button>
                <button class="btn-delete-credential" data-index="${index}" title="Delete">×</button>
            </div>
        `;
        
        credentialsList.appendChild(item);
    });
    
    // Add event listeners to the buttons
    document.querySelectorAll('.btn-use-credential').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = e.target.getAttribute('data-index');
            useCredential(index);
        });
    });
    
    document.querySelectorAll('.btn-delete-credential').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const index = e.target.getAttribute('data-index');
            deleteCredential(index);
        });
    });
}

btnSaveCredential.addEventListener('click', () => {
    const site = credentialSiteInput.value.trim();
    const username = credentialUsernameInput.value.trim();
    const password = credentialPasswordInput.value.trim();
    
    if (!site || !username || !password) {
        showMessage('Please fill all fields');
        return;
    }
    
    // Check if credential already exists for this site and username
    const existingIndex = savedCredentials.findIndex(
        c => c.site === site && c.username === username
    );
    
    if (existingIndex >= 0) {
        // Update existing credential
        savedCredentials[existingIndex].password = password;
    } else {
        // Add new credential
        savedCredentials.push({ site, username, password });
    }
    
    saveCredentials();
    updateCredentialsList();
    
    // Clear form
    credentialSiteInput.value = '';
    credentialUsernameInput.value = '';
    credentialPasswordInput.value = '';
});

function saveCredentials() {
    localStorage.setItem('savedCredentials', JSON.stringify(savedCredentials));
}

async function deleteCredential(index) {
    const confirmed = await showConfirm('Delete this saved login?');
    if (confirmed) {
        savedCredentials.splice(index, 1);
        saveCredentials();
        updateCredentialsList();
        showMessage('Credential deleted!');
    }
}

function useCredential(index) {
    const credential = savedCredentials[index];
    if (!credential) return;

    // Garante que existe um board
    if (!currentBoardId) {
        showMessage('No board open');
        return;
    }

    const board = boards[currentBoardId];

    // Se não há activeTabId, tenta pegar o primeiro tab do board
    if (!activeTabId && board.tabs.length > 0) {
        activeTabId = board.tabs[0].id;
    }

    const tab = board.tabs.find(t => t.id === activeTabId);

    if (!tab) {
        showMessage('Please open a webview first');
        return;
    }

    // Injeta o login no webview ativo
    tab.webview.executeJavaScript(`(function() {
            // Find all input fields
            const inputs = document.querySelectorAll('input');
            let usernameField, passwordField;
            
            // Try to identify username/email and password fields
            inputs.forEach(input => {
                const lowerType = input.type.toLowerCase();
                const lowerName = (input.name || '').toLowerCase();
                const lowerId = (input.id || '').toLowerCase();
                
                if (lowerType === 'email' || lowerType === 'text' || 
                    lowerName.includes('email') || lowerName.includes('user') || 
                    lowerId.includes('email') || lowerId.includes('user')) {
                    usernameField = input;
                }
                
                if (lowerType === 'password' || 
                    lowerName.includes('pass') || 
                    lowerId.includes('pass')) {
                    passwordField = input;
                }
            });
            
            // Fill the fields if found
            if (usernameField) {
                usernameField.value = '${credential.username.replace(/'/g, "\\'")}';
                // Trigger change event
                const event = new Event('input', { bubbles: true });
                usernameField.dispatchEvent(event);
            }
            
            if (passwordField) {
                passwordField.value = '${credential.password.replace(/'/g, "\\'")}';
                // Trigger change event
                const event = new Event('input', { bubbles: true });
                passwordField.dispatchEvent(event);
            }
            
            // Try to find and click the submit button
            if (usernameField && passwordField) {
                // Look for a submit button near the form
                let form = usernameField.closest('form');
                if (!form) form = passwordField.closest('form');
                
                if (form) {
                    const submitButton = form.querySelector('button[type="submit"], input[type="submit"]');
                    if (submitButton) {
                        submitButton.click();
                    }
                }
            }
            
            return {
                usernameField: !!usernameField,
                passwordField: !!passwordField
            };
        })();
    `).then(result => {
        if (!result.usernameField || !result.passwordField) {
            showMessage('Could not find login fields on this page. Please make sure you\'re on the login page.');
            
        }
        credentialsModal.style.display = 'none';
    }).catch(err => {
        console.error('Error injecting credentials:', err);
        showMessage('Error injecting credentials. The page may have restrictions.');
        
    });
}

function showMessage(message, time=2000) {
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.background = '#333';
    modal.style.color = 'white';
    modal.style.padding = '20px';
    modal.style.borderRadius = '8px';
    modal.style.zIndex = 100000;
    modal.innerText = message;
    document.body.appendChild(modal);

    setTimeout(() => {
        modal.remove();
    }, time);
}




// Auto-fill credentials when page loads
function setupAutoFill() {
    if (!currentBoardId || !activeTabId) return;
    
    const board = boards[currentBoardId];
    const tab = board.tabs.find(t => t.id === activeTabId);
    if (!tab) return;
    
    tab.webview.addEventListener('did-navigate', (e) => {
        const url = e.url;
        if (!url) return;
        
        // Find matching credentials for this domain
        const domain = new URL(url).hostname.replace('www.', '');
        const matchingCreds = savedCredentials.filter(c => 
            url.includes(c.site) || domain.includes(c.site.replace('www.', ''))
        );
        
        if (matchingCreds.length > 0) {
            // Use the first matching credential
            tab.webview.executeJavaScript(`
                (function() {
                    // Check if we're on a login page by looking for password fields
                    const passwordFields = document.querySelectorAll('input[type="password"]');
                    if (passwordFields.length === 0) return false;
                    
                    return true;
                })();
            `).then(isLoginPage => {
                if (isLoginPage) {
                    useCredential(savedCredentials.indexOf(matchingCreds[0]));
                }
            });
        }
    });
}

// Initialize auto-fill when a new tab is created
const originalCreateTab = createTab;
createTab = function(url, savedState, targetBoardId) {
    const tabId = originalCreateTab(url, savedState, targetBoardId);
    setTimeout(() => setupAutoFill(), 500);
    return tabId;
};

const { ipcRenderer } = require('electron');

let completedDownloadsCount = 0; // Mudança: separar contadores
const activeDownloads = new Map();

function openDownloadsModal() {
    document.getElementById('downloadsModal').style.display = 'block';
    loadDownloads();
    loadActiveDownloads();
}

function closeDownloadsModal() {
    document.getElementById('downloadsModal').style.display = 'none';
}

async function loadDownloads() {
    try {
        const downloads = await ipcRenderer.invoke('get-completed-downloads');
        completedDownloadsCount = downloads.length; // Atualiza contador
        displayDownloads(downloads);
    } catch (error) {
        console.error('Erro ao carregar downloads:', error);
    }
}

async function loadActiveDownloads() {
    try {
        const downloads = await ipcRenderer.invoke('get-active-downloads');
        downloads.forEach(download => {
            activeDownloads.set(download.id, download);
        });
        displayActiveDownloads();
    } catch (error) {
        console.error('Erro ao carregar downloads ativos:', error);
    }
}

function displayDownloads(downloads) {
    const downloadsList = document.getElementById('downloadsList');
    
    // Primeiro, exibe downloads ativos
    displayActiveDownloads();
    
    // Depois, adiciona downloads concluídos
    const completedHtml = downloads.length > 0 ? downloads.map(download => `
        <div class="download-item completed">
            <div class="download-info">
                <div class="download-name">${download.fileName}</div>
                <div class="download-details">
                    ${download.completedAt} • ${formatFileSize(download.size)}
                </div>
            </div>
            <div class="download-status completed">✓ Finished</div>
        </div>
    `).join('') : '';
    
    if (activeDownloads.size === 0 && downloads.length === 0) {
        downloadsList.innerHTML = '<div class="empty-state"><p>No downloads have finished yet.</p></div>';
    } else {
        const activeHtml = displayActiveDownloads();
        downloadsList.innerHTML = activeHtml + completedHtml;
    }
}

function displayActiveDownloads() {
    if (activeDownloads.size === 0) return '';
    
    const activeHtml = Array.from(activeDownloads.values()).map(download => `
        <div class="download-item active" id="download-${download.id}">
            <div class="download-info">
                <div class="download-name">${download.fileName}</div>
                <div class="download-details">
                    ${formatFileSize(download.receivedBytes)} / ${formatFileSize(download.totalBytes)} • ${download.progress.toFixed(1)}%
                </div>
            </div>
            <div class="download-progress">
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${download.progress}%"></div>
                </div>
            </div>
        </div>
    `).join('');
    
    // Se o modal estiver aberto, atualiza o conteúdo
    const downloadsList = document.getElementById('downloadsList');
    if (downloadsList && activeDownloads.size > 0) {
        // Preserva downloads concluídos e atualiza apenas os ativos
        const completedItems = downloadsList.querySelectorAll('.download-item.completed');
        const completedHtml = Array.from(completedItems).map(item => item.outerHTML).join('');
        downloadsList.innerHTML = activeHtml + completedHtml;
    }
    
    return activeHtml;
}

async function clearDownloads() {
    try {
        await ipcRenderer.invoke('clear-completed-downloads');
        completedDownloadsCount = 0; // Zera contador de concluídos
        updateDownloadsBadge();
        displayDownloads([]);
    } catch (error) {
        console.error('Erro ao limpar downloads:', error);
    }
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function updateDownloadsBadge() {
    const badge = document.getElementById('downloadsBadge');
    const totalDownloads = completedDownloadsCount + activeDownloads.size;
    
    if (totalDownloads > 0) {
        badge.textContent = totalDownloads;
        badge.style.display = 'inline-flex';
    } else {
        badge.style.display = 'none';
    }
}

ipcRenderer.on('download-started', (event, downloadInfo) => {
    activeDownloads.set(downloadInfo.id, downloadInfo);
    updateDownloadsBadge();
    
    // Se o modal estiver aberto, atualiza a exibição
    if (document.getElementById('downloadsModal').style.display === 'block') {
        displayActiveDownloads();
    }
});

// Listener para progresso de download
ipcRenderer.on('download-progress', (event, progressInfo) => {
    const download = activeDownloads.get(progressInfo.id);
    if (download) {
        download.receivedBytes = progressInfo.receivedBytes;
        download.totalBytes = progressInfo.totalBytes;
        download.progress = progressInfo.progress;
        
        activeDownloads.set(progressInfo.id, download);
        
        // Atualiza o item específico se o modal estiver aberto
        const downloadElement = document.getElementById(`download-${progressInfo.id}`);
        if (downloadElement) {
            const detailsElement = downloadElement.querySelector('.download-details');
            const progressFill = downloadElement.querySelector('.progress-fill');
            
            if (detailsElement) {
                detailsElement.textContent = `${formatFileSize(progressInfo.receivedBytes)} / ${formatFileSize(progressInfo.totalBytes)} • ${progressInfo.progress.toFixed(1)}%`;
            }
            
            if (progressFill) {
                progressFill.style.width = `${progressInfo.progress}%`;
            }
        }

        if (sidebar.classList.contains('open') && sidebarTitle.textContent === 'Downloads') {
            loadDownloadsSidebar();
        }
    }
});

// Listener para download removido (concluído ou interrompido)
ipcRenderer.on('download-removed', (event, downloadId) => {
    activeDownloads.delete(downloadId);
    updateDownloadsBadge();
    
    // Remove o elemento do DOM se o modal estiver aberto
    const downloadElement = document.getElementById(`download-${downloadId}`);
    if (downloadElement) {
        downloadElement.remove();
    }
});

// Listener para novos downloads concluídos
ipcRenderer.on('download-completed', (event, downloadInfo) => {
    completedDownloadsCount++; // Incrementa contador de concluídos
    updateDownloadsBadge(); // Atualiza badge apenas quando download termina
    
    // Se o modal estiver aberto, recarrega os downloads
    if (document.getElementById('downloadsModal').style.display === 'block') {
        loadDownloads();
    }
    if (sidebar.classList.contains('open') && sidebarTitle.textContent === 'Downloads') {
        loadDownloadsSidebar();
    }
});

// Listener para downloads interrompidos
ipcRenderer.on('download-interrupted', (event, info) => {
    console.log('Download interrompido:', info.fileName);
    // Você pode adicionar uma notificação aqui se desejar
});

// Fechar modal ao clicar fora
document.getElementById('downloadsModal').addEventListener('click', (e) => {
    if (e.target.id === 'downloadsModal') {
        closeDownloadsModal();
    }
});

// Carregar contagem inicial de downloads
loadDownloads().then(() => {
    updateDownloadsBadge();
});

// Carregar downloads ativos iniciais
loadActiveDownloads();





ctxChangeTheme.addEventListener('click', () => {
    showThemeColorModal();
    contextMenu.style.display = 'none';
});

ctxResetTheme.addEventListener('click', () => {
    const defaultColor = '#007acc';
    document.getElementById('theme-color-hex').value = defaultColor;
    document.getElementById('selected-color-preview').style.backgroundColor = defaultColor;
    
    // Posiciona o seletor na cor padrão
    const colorSpectrum = document.getElementById('color-spectrum');
    const colorSelector = document.getElementById('color-selector');
    const hue = getHueFromHex(defaultColor);
    const x = (hue / 360) * colorSpectrum.offsetWidth;
    const y = colorSpectrum.offsetHeight / 2;
    colorSelector.style.left = x + 'px';
    colorSelector.style.top = y + 'px';
});


function showThemeColorModal() {
    const modal = document.getElementById('themeColorModal');
    const colorSpectrum = document.getElementById('color-spectrum');
    const colorSelector = document.getElementById('color-selector');
    const colorPreview = document.getElementById('selected-color-preview');
    const hexInput = document.getElementById('theme-color-hex');

    // Configura a cor inicial
    hexInput.value = currentThemeColor;
    colorPreview.style.backgroundColor = currentThemeColor;

    // Posiciona o seletor baseado na cor atual (simplificado)
    if (currentThemeColor) {
        // Esta é uma aproximação simples - em uma implementação real você precisaria
        // mapear a cor HEX para uma posição no espectro
        const hue = getHueFromHex(currentThemeColor);
        const x = (hue / 360) * colorSpectrum.offsetWidth;
        const y = colorSpectrum.offsetHeight / 2;
        colorSelector.style.left = x + 'px';
        colorSelector.style.top = y + 'px';
    }

    modal.style.display = 'flex';

    // Configura o evento de seleção de cor
    let isSelecting = false;

    colorSpectrum.addEventListener('mousedown', (e) => {
        isSelecting = true;
        updateColor(e);
    });

    window.addEventListener('mousemove', (e) => {
        if (isSelecting) {
            updateColor(e);
        }
    });

    window.addEventListener('mouseup', () => {
        isSelecting = false;
    });

    function updateColor(e) {
        const rect = colorSpectrum.getBoundingClientRect();
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;

        // Limita as coordenadas dentro do espectro
        x = Math.max(0, Math.min(x, rect.width));
        y = Math.max(0, Math.min(y, rect.height));

        // Atualiza a posição do seletor
        colorSelector.style.left = x + 'px';
        colorSelector.style.top = y + 'px';

        // Calcula a cor baseada na posição (simplificado)
        const hue = (x / rect.width) * 360;
        const saturation = 100;
        const lightness = 50 - ((y / rect.height) * 30);
        const color = hslToHex(hue, saturation, lightness);

        // Atualiza a visualização
        hexInput.value = color;
        colorPreview.style.backgroundColor = color;
    }

    // Função auxiliar para converter HSL para HEX
    function hslToHex(h, s, l) {
        h /= 360;
        s /= 100;
        l /= 100;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        const toHex = x => {
            const hex = Math.round(x * 255).toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        };

        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    // Função auxiliar para obter matiz de uma cor HEX
    function getHueFromHex(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h;

        if (max === min) {
            h = 0;
        } else {
            const d = max - min;
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return h * 360;
    }
}

document.getElementById('btnSaveThemeColor').addEventListener('click', () => {
    const hexInput = document.getElementById('theme-color-hex');
    const newColor = hexInput.value;

    if (/^#[0-9A-F]{6}$/i.test(newColor)) {
        currentThemeColor = newColor;
        localStorage.setItem('themeColor', newColor);
        applyThemeColor();
        document.getElementById('themeColorModal').style.display = 'none';
    } else {
        showMessage('Please select a valid color.');
    }
});

function applyThemeColor() {
    // Atualiza a variável CSS
    document.documentElement.style.setProperty('--theme-color', currentThemeColor);

    // Calcula o valor RGB para a sombra (opcional)
    const r = parseInt(currentThemeColor.slice(1, 3), 16);
    const g = parseInt(currentThemeColor.slice(3, 5), 16);
    const b = parseInt(currentThemeColor.slice(5, 7), 16);
    document.documentElement.style.setProperty('--theme-color-rgb', `${r}, ${g}, ${b}`);
}




let defaultStartPage = localStorage.getItem('startPage') || 'https://www.google.com';
let defaultSearchEngine = localStorage.getItem('searchEngine') || 'google';
let defaultAIOption= localStorage.getItem('defaultAIOption') || 'AIdisabled';

let lastRightClickPosition = null;
let boards = {};
let currentBoardId = null;
let tabIdCounter = 0;
let textFieldIdCounter = 0;
let listIdCounter = 0;
let boardIdCounter = 0;
let activeTabId = null;
let activeTextFieldId = null;
let activeListId = null;
let currentZoom = 100;
let isDraggingDesktop = false;
let startDragX, startDragY;
let startScrollLeft, startScrollTop;
let favorites = JSON.parse(localStorage.getItem('browserFavorites')) || [];
let isDrawing = false;
let currentColor = '#ff0000';
let currentBrushSize = 5;
let isErasing = false;
let drawingData = JSON.parse(localStorage.getItem('drawingData')) || {};
let browsingHistory = JSON.parse(localStorage.getItem('browsingHistory')) || [];

btnClearHistory.addEventListener('click', async () => {
    const confirmed = await showConfirm('Are you sure you want to clear the browsing history?');
    if (confirmed) {
        browsingHistory = [];
        localStorage.setItem('browsingHistory', JSON.stringify(browsingHistory));
        showMessage('Browsing history cleared.');
        
    }
});

function addToHistory(url) {
    if (!browsingHistory.includes(url)) {
        browsingHistory.unshift(url);
        localStorage.setItem('browsingHistory', JSON.stringify(browsingHistory));
    }
}

historySearch.addEventListener('input', (e) => {
    filterHistory(e.target.value.toLowerCase());
});

function filterHistory(searchTerm) {
    const historyItems = document.querySelectorAll('.history-item');

    historyItems.forEach(item => {
        const url = item.textContent.toLowerCase();
        if (url.includes(searchTerm)) {
            item.style.display = 'block';
        } else {
            item.style.display = 'none';
        }
    });
}

desktop.addEventListener('contextmenu', (e) => {
    e.preventDefault();

    // Esconde outros menus abertos
    dropdownMenu.style.display = 'none';
    moreOptionsMenu.style.display = 'none';
    colorPickerMenu.style.display = 'none';

    // Posiciona o menu de contexto
    contextMenu.style.display = 'block';
    contextMenu.style.left = `${e.clientX}px`;
    contextMenu.style.top = `${e.clientY}px`;

    // Armazena a posição do clique para criar elementos depois
    lastRightClickPosition = {
        x: e.clientX - desktop.getBoundingClientRect().left,
        y: e.clientY - desktop.getBoundingClientRect().top
    };
});

// Fecha o menu ao clicar em qualquer lugar
document.addEventListener('click', () => {
    contextMenu.style.display = 'none';
});

// Fecha o menu ao pressionar ESC
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        contextMenu.style.display = 'none';
    }
});

// Eventos dos itens do menu
ctxCreateTab.addEventListener('click', () => {
    createTab();
    contextMenu.style.display = 'none';
});

ctxCreateTextField.addEventListener('click', () => {
    createTextField();
    contextMenu.style.display = 'none';
});

ctxCreateList.addEventListener('click', () => {
    createList();
    contextMenu.style.display = 'none';
});

btnHistory.addEventListener('click', () => {
    showHistoryModal();
    moreOptionsMenu.style.display = 'none';
});

function showHistoryModal() {
    updateHistoryList();
    let historyHtml = `<div class="form-group"><input type="text" id="historySearchSidebar" class="form-control" placeholder="Search history..."></div><div class="history-list">`;
  if (browsingHistory.length === 0) {
    historyHtml += '<div class="no-history">No browsing history yet.</div>';
  } else {
    browsingHistory.forEach(url => {
      historyHtml += `<div class="history-item" data-url="${url}">${url}</div>`;
    });
  }
  historyHtml += `</div><div class="modal-footer"><button class="modal-button modal-button-secondary" id="btnClearHistorySidebar2">Clear History</button></div>`;
  openSidebar('Browsing History', historyHtml);
  document.getElementById('historySearchSidebar').oninput = (e) => {
    const searchTerm = e.target.value.toLowerCase();
    document.querySelectorAll('.history-item').forEach(item => {
      item.style.display = item.textContent.toLowerCase().includes(searchTerm) ? 'block' : 'none';
    });
  };
  document.querySelectorAll('.history-item').forEach(item => {
    item.onclick = () => {
      createTab(item.dataset.url);
      closeSidebar();
    };
  });
  document.getElementById('btnClearHistorySidebar2').onclick = async () => {
    const confirmed = await showConfirm("Are you sure you want to clear all browsing history?");
    if (confirmed) {
      browsingHistory = [];
      localStorage.setItem('browsingHistory', JSON.stringify(browsingHistory));
      closeSidebar();
      btnHistory.click();
    }
  };
}

function updateHistoryList() {
    historyList.innerHTML = '';

    if (browsingHistory.length === 0) {
        const noHistory = document.createElement('div');
        noHistory.classList.add('no-history');
        noHistory.textContent = 'No browsing history yet.';
        historyList.appendChild(noHistory);
        return;
    }

    // Mostra os itens mais recentes primeiro


    browsingHistory.forEach(url => {
        const item = document.createElement('div');
        item.classList.add('history-item');
        item.textContent = url;

        item.addEventListener('click', () => {
            createTab(url);
            historyModal.style.display = 'none';
        });

        historyList.appendChild(item);
    });

    // Limpa o campo de pesquisa quando a lista é atualizada
    historySearch.value = '';
}

btnClearHistoryModal.addEventListener('click', async () => {
    const confirmed = await showConfirm("Are you sure you want to clear all browsing history?");
    if (confirmed) {
        browsingHistory = [];
        localStorage.setItem('browsingHistory', JSON.stringify(browsingHistory));
        updateHistoryList();
    }
});




btnSettings.addEventListener('click', () => {
    startPageInput.value = defaultStartPage;
    searchEngineSelect.value = defaultSearchEngine;
    settingsModal.style.display = 'flex';
    moreOptionsMenu.style.display = 'none';
});

btnSaveSettings.addEventListener('click', () => {
    defaultStartPage = startPageInput.value.trim() || 'https://www.google.com';
        defaultSearchEngine = searchEngineSelect.value;
        localStorage.setItem('startPage', defaultStartPage);
        localStorage.setItem('searchEngine', defaultSearchEngine);
        settingsModal.style.display = 'none';
});



btnClean.addEventListener('click', async (e) => {
    e.stopPropagation();

    const confirmed = await showConfirm('Are you sure you want to clear the board?');
    // Confirmação antes de limpar
    if (confirmed) {
        clearDrawing();
        showMessage('Board cleaned.');
        
    }
});

function clearDrawing() {
    ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    delete drawingData[currentBoardId];
    localStorage.setItem('drawingData', JSON.stringify(drawingData));
    loadDrawing(); // Recarrega o canvas vazio
}

// Inicializa o canvas de desenho
function initDrawingCanvas() {
    resizeCanvas();
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.globalCompositeOperation = 'source-over';
    loadDrawing();
    setupDrawingEvents();
}

function resizeCanvas() {
    drawingCanvas.width = desktop.offsetWidth * (currentZoom / 100);
    drawingCanvas.height = desktop.offsetHeight * (currentZoom / 100);
    loadDrawing();
}

function setupDrawingEvents() {
    drawingCanvas.removeEventListener('mousedown', startDrawing);
    drawingCanvas.removeEventListener('mousemove', draw);
    drawingCanvas.removeEventListener('mouseup', stopDrawing);
    drawingCanvas.removeEventListener('mouseout', stopDrawing);
    drawingCanvas.removeEventListener('touchstart', handleTouchStart);
    drawingCanvas.removeEventListener('touchmove', handleTouchMove);
    drawingCanvas.removeEventListener('touchend', handleTouchEnd);

    drawingCanvas.addEventListener('mousedown', startDrawing);
    drawingCanvas.addEventListener('mousemove', draw);
    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseout', stopDrawing);
    drawingCanvas.addEventListener('touchstart', handleTouchStart);
    drawingCanvas.addEventListener('touchmove', handleTouchMove);
    drawingCanvas.addEventListener('touchend', handleTouchEnd);
}

function startDrawing(e) {
    if (!isDrawingModeActive()) return;

    isDrawing = true;
    const rect = drawingCanvas.getBoundingClientRect();
    const scale = currentZoom / 100;

    let x = (e.clientX - rect.left) / scale;
    let y = (e.clientY - rect.top) / scale;

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x, y);
    ctx.stroke();
}

function draw(e) {
    if (!isDrawing) return;

    const rect = drawingCanvas.getBoundingClientRect();
    const scale = currentZoom / 100;

    let x = (e.clientX - rect.left) / scale;
    let y = (e.clientY - rect.top) / scale;

    if (isErasing) {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
        ctx.globalCompositeOperation = 'source-over';
        ctx.strokeStyle = currentColor;
    }

    ctx.lineWidth = currentBrushSize;
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
    saveDrawing();
}

function stopDrawing() {
    if (!isDrawing) return;

    isDrawing = false;
    ctx.beginPath();
    saveDrawing();
}

function saveDrawing() {
    const dataUrl = drawingCanvas.toDataURL();
    drawingData[currentBoardId] = dataUrl;
    localStorage.setItem('drawingData', JSON.stringify(drawingData));
}

function loadDrawing() {
    if (!drawingData[currentBoardId]) {
        ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        return;
    }

    const img = new Image();
    img.onload = function() {
        ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        ctx.drawImage(img, 0, 0);
    };
    img.src = drawingData[currentBoardId];
}

function clearDrawing() {
    ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    delete drawingData[currentBoardId];
    localStorage.setItem('drawingData', JSON.stringify(drawingData));
}

function isDrawingModeActive() {
    return btnBrush.classList.contains('active') || btnEraser.classList.contains('active');
}

function handleTouchStart(e) {
    e.preventDefault();
    if (!isDrawingModeActive()) return;

    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    drawingCanvas.dispatchEvent(mouseEvent);
}

function handleTouchMove(e) {
    e.preventDefault();
    if (!isDrawingModeActive()) return;

    const touch = e.touches[0];
    const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    drawingCanvas.dispatchEvent(mouseEvent);
}

function handleTouchEnd(e) {
    e.preventDefault();
    if (!isDrawingModeActive()) return;

    const mouseEvent = new MouseEvent('mouseup', {});
    drawingCanvas.dispatchEvent(mouseEvent);
}

// Configura eventos para as ferramentas de desenho
btnBrush.addEventListener('click', () => {
    btnBrush.classList.toggle('active');

    if (btnBrush.classList.contains('active')) {
        btnEraser.classList.remove('active');
        btnMoveMode.classList.remove('active');
        isMoveModeActive = false;
        isErasing = false;
        drawingCanvas.classList.add('drawing-mode');
        drawingCanvas.classList.remove('erasing-mode');
        colorPickerMenu.style.display = 'flex';
    } else {
        drawingCanvas.classList.remove('drawing-mode');
        colorPickerMenu.style.display = 'none';
    }
});

btnEraser.addEventListener('click', () => {
    btnEraser.classList.toggle('active');

    if (btnEraser.classList.contains('active')) {
        btnBrush.classList.remove('active');
        btnMoveMode.classList.remove('active');
        isMoveModeActive = false;
        isErasing = true;
        drawingCanvas.classList.add('erasing-mode');
        drawingCanvas.classList.remove('drawing-mode');
        colorPickerMenu.style.display = 'none';
    } else {
        drawingCanvas.classList.remove('erasing-mode');
    }
});

btnMoveMode.addEventListener('click', () => {
    isMoveModeActive = !isMoveModeActive;
    btnMoveMode.classList.toggle('active');

    // Atualiza o cursor dos cabeçalhos de Text Fields e Lists
    document.querySelectorAll('.textfield-header, .list-header').forEach(header => {
        header.style.cursor = isMoveModeActive ? 'move' : 'default';
    });

    if (isMoveModeActive) {
        btnBrush.classList.remove('active');
        btnEraser.classList.remove('active');
        isDrawing = false;
        drawingCanvas.classList.remove('drawing-mode');
        drawingCanvas.classList.remove('erasing-mode');
        colorPickerMenu.style.display = 'none';
    }
});

// Mostra/esconde o menu de seleção de cores
btnBrush.addEventListener('mouseenter', () => {
    if (btnBrush.classList.contains('active')) {
        colorPickerMenu.style.display = 'flex';
    }
});

btnBrush.addEventListener('mouseleave', () => {
    colorPickerMenu.style.display = 'none';
});

colorPickerMenu.addEventListener('mouseenter', () => {
    colorPickerMenu.style.display = 'flex';
});

colorPickerMenu.addEventListener('mouseleave', () => {
    colorPickerMenu.style.display = 'none';
});

// Seleciona cor
colorOptions.forEach(option => {
    option.addEventListener('click', () => {
        colorOptions.forEach(opt => opt.classList.remove('selected'));
        option.classList.add('selected');
        currentColor = option.dataset.color;
    });
});

// Ajusta tamanho do pincel
brushSizeControl.addEventListener('input', () => {
    currentBrushSize = brushSizeControl.value;
    brushSizeValue.textContent = `${currentBrushSize}px`;
});

// Controle do dropdown menu
btnNewTab.addEventListener('mouseenter', () => {
    dropdownMenu.style.display = 'block';
});

btnNewTab.parentElement.addEventListener('mouseleave', () => {
    dropdownMenu.style.display = 'none';
});

btnCreateTab.addEventListener('click', () => {
    createTab();
    dropdownMenu.style.display = 'none';
});

btnCreateTabAnon.addEventListener('click', () => {
    createTabAnonima();
    dropdownMenu.style.display = 'none';
});

btnCreateTextField.addEventListener('click', () => {
    createTextField();
    dropdownMenu.style.display = 'none';
});

btnCreateList.addEventListener('click', () => {
    createList();
    dropdownMenu.style.display = 'none';
});

btnCreateBoard.addEventListener('click', () => {
    createBoard(`Board ${boardIdCounter + 1}`);
    dropdownMenu.style.display = 'none';
});

// Controle do menu de mais opções
btnMoreOptions.addEventListener('click', (e) => {
    e.stopPropagation();
    moreOptionsMenu.style.display = moreOptionsMenu.style.display === 'block' ? 'none' : 'block';
    dropdownMenu.style.display = 'none';
});

document.addEventListener('click', (e) => {
    if (!btnMoreOptions.contains(e.target) && !moreOptionsMenu.contains(e.target)) {
        moreOptionsMenu.style.display = 'none';
    }
});

document.addEventListener('click', (e) => {
    if (!contextMenu.contains(e.target)) {
        contextMenu.style.display = 'none';
    }
});

// Função para exportar boards
btnExportBoards.addEventListener('click', () => {
    exportBoards();
    moreOptionsMenu.style.display = 'none';
});

// Função para importar boards
btnImportBoards.addEventListener('click', () => {
    showImportModal();
    moreOptionsMenu.style.display = 'none';
});

// Função para renomear boards
btnRenameBoards.addEventListener('click', () => {
    showRenameModal();
    moreOptionsMenu.style.display = 'none';
});

// Controles de zoom
zoomOutBtn.addEventListener('click', () => {
    setZoom(Math.max(30, currentZoom - 10));
});

zoomInBtn.addEventListener('click', () => {
    setZoom(Math.min(150, currentZoom + 10));
});

zoomSlider.addEventListener('input', (e) => {
    setZoom(parseInt(e.target.value));
});

resetZoomBtn.addEventListener('click', () => {
    setZoom(100);
});



// Botão de favoritos
btnFavorites.addEventListener('click', (e) => {
    e.stopPropagation();
    showFavoritesModal();
});

// Função para mostrar o modal de favoritos
function showFavoritesModal() {
    updateFavoritesGrid();
    favoritesModal.style.display = 'flex';
}

// Função para atualizar a grade de favoritos
function updateFavoritesGrid() {
    favoritesGrid.innerHTML = '';

    if (favorites.length === 0) {
        const noFavorites = document.createElement('div');
        noFavorites.classList.add('no-favorites');
        noFavorites.textContent = 'No favorites yet. Pin websites using the pin button in webview controls.';
        favoritesGrid.appendChild(noFavorites);
        return;
    }

    favorites.forEach((favorite, index) => {
        const favoriteItem = document.createElement('div');
        favoriteItem.classList.add('favorite-item');
        favoriteItem.dataset.url = favorite.url;

        const icon = document.createElement('img');
        icon.classList.add('favorite-icon');
        icon.src = `https://www.google.com/s2/favicons?domain=${new URL(favorite.url).hostname}`;
        icon.alt = favorite.title;

        const title = document.createElement('div');
        title.classList.add('favorite-title');
        title.textContent = "";
        favoriteItem.appendChild(icon);
        favoriteItem.appendChild(title);
        favoritesGrid.appendChild(favoriteItem);

        favoriteItem.addEventListener('click', () => {
            createTab(favorite.url);
            favoritesModal.style.display = 'none';
        });
    });
}

// Função para adicionar um favorito
function addFavorite(url, title) {
    if (favorites.some(fav => fav.url === url)) {
        return;
    }

    favorites.push({
        url,
        title: title || new URL(url).hostname
    });

    saveFavorites();
    updateFavoritesGrid();
}

// Função para remover um favorito
function removeFavorite(url) {
    favorites = favorites.filter(fav => fav.url !== url);
    saveFavorites();
    updateFavoritesGrid();
}

// Função para salvar favoritos no localStorage
function saveFavorites() {
    localStorage.setItem('browserFavorites', JSON.stringify(favorites));
}

// Função para verificar se uma URL está nos favoritos
function isFavorite(url) {
    return favorites.some(fav => fav.url === url);
}

// Função para aplicar o zoom
function setZoom(zoomLevelValue) {
    currentZoom = zoomLevelValue;
    zoomSlider.value = currentZoom;
    zoomLevel.textContent = `${currentZoom}%`;

    desktop.style.transform = `scale(${currentZoom / 100})`;
    desktop.style.width = `${100 / (currentZoom / 100)}%`;
    desktop.style.height = `${100 / (currentZoom / 100)}%`;
    desktop.style.position = currentZoom === 100 ? 'relative' : 'absolute';

    if (currentZoom !== 100) {
        desktop.style.cursor = 'grab';
        desktop.style.userSelect = 'none';
    } else {
        desktop.style.cursor = '';
        desktop.style.userSelect = '';
    }

    resizeCanvas();
    saveState();
}

// Função para arrastar o desktop com zoom
desktop.addEventListener('mousedown', (e) => {
    if (currentZoom === 100 || e.target !== desktop) return;

    isDraggingDesktop = true;
    startDragX = e.clientX;
    startDragY = e.clientY;
    startScrollLeft = desktopContainer.scrollLeft;
    startScrollTop = desktopContainer.scrollTop;
    desktop.style.cursor = 'grabbing';
    e.preventDefault();
});

window.addEventListener('mousemove', (e) => {
    if (!isDraggingDesktop || currentZoom === 100) return;

    const dx = e.clientX - startDragX;
    const dy = e.clientY - startDragY;

    desktopContainer.scrollLeft = startScrollLeft - dx;
    desktopContainer.scrollTop = startScrollTop - dy;
});

window.addEventListener('mouseup', () => {
    isDraggingDesktop = false;
    if (currentZoom !== 100) {
        desktop.style.cursor = 'grab';
    }
});

// Função para exportar os boards para um arquivo JSON
function exportBoards() {
    const state = {
        boards: {},
        currentBoardId,
        currentZoom,
        nextTabId: tabIdCounter,
        nextTextFieldId: textFieldIdCounter,
        nextListId: listIdCounter,
        nextBoardId: boardIdCounter,
        favorites: favorites,
        drawingData: drawingData
    };

    Object.keys(boards).forEach(boardId => {
        const board = boards[boardId];
        state.boards[boardId] = {
            id: board.id,
            name: board.name,
            activeTabId: board.activeTabId,
            activeTextFieldId: board.activeTextFieldId,
            activeListId: board.activeListId,
            tabs: board.tabs.map(tab => ({
                id: tab.id,
                url: tab.webview.src,
                position: {
                    top: tab.tabFrame.style.top,
                    left: tab.tabFrame.style.left,
                    zIndex: tab.tabFrame.style.zIndex
                },
                size: {
                    width: tab.tabFrame.style.width,
                    height: tab.tabFrame.style.height
                },
                maximized: tab.tabFrame.classList.contains('maximized-tab')
            })),
            textFields: board.textFields.map(textField => ({
                id: textField.id,
                content: textField.textarea.value,
                title: textField.textFieldFrame.querySelector('.title-section').value,
                                                           position: {
                                                               top: textField.textFieldFrame.style.top,
                                                               left: textField.textFieldFrame.style.left,
                                                               zIndex: textField.textFieldFrame.style.zIndex
                                                           },
                                                           size: {
                                                               width: textField.textFieldFrame.style.width,
                                                               height: textField.textFieldFrame.style.height
                                                           },
                                                           maximized: textField.textFieldFrame.classList.contains('maximized-textfield')
            })),
            lists: board.lists.map(list => ({
                id: list.id,
                title: list.listFrame.querySelector('.title-section').value,
                                            items: Array.from(list.listContent.querySelectorAll('.list-item')).map(item => ({
                                                checked: item.querySelector('input[type="checkbox"]').checked,
                                                                                                                            text: item.querySelector('input[type="text"]').value
                                            })),
                                            position: {
                                                top: list.listFrame.style.top,
                                                left: list.listFrame.style.left,
                                                zIndex: list.listFrame.style.zIndex
                                            },
                                            size: {
                                                width: list.listFrame.style.width,
                                                height: list.listFrame.style.height
                                            },
                                            maximized: list.listFrame.classList.contains('maximized-list')
            }))
        };
    });

    const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = `boards_export_${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();

    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 0);
}

// Função para mostrar o modal de importação
function showImportModal() {
    importModal.style.display = 'flex';
    importFileName.textContent = 'Nenhum arquivo selecionado';
    btnImportConfirm.disabled = true;
}

// Função para mostrar o modal de renomear
function showRenameModal() {
    let renameHtml = `<div class="form-group">
    <label for="renameBoardSelectSidebar">Select the Board:</label>
    <select id="renameBoardSelectSidebar" class="form-control">`;
  Object.keys(boards).forEach(boardId => {
    renameHtml += `<option value="${boardId}">${boards[boardId].name}</option>`;
  });
  renameHtml += `</select></div>
    <div class="form-group">
      <label for="renameBoardInputSidebar">New Name:</label>
      <input type="text" id="renameBoardInputSidebar" class="form-control" placeholder="Enter new name">
    </div>
    <div class="modal-footer">
      <button class="modal-button modal-button-primary" id="btnSaveRenameSidebar">Save</button>
    </div>`;
  openSidebar('Rename Board', renameHtml);
  const select = document.getElementById('renameBoardSelectSidebar');
  const input = document.getElementById('renameBoardInputSidebar');
  select.onchange = () => {
    input.value = boards[select.value].name;
  };
  input.value = boards[select.value].name;
  document.getElementById('btnSaveRenameSidebar').onclick = () => {
    const boardId = select.value;
    const newName = input.value.trim();
    if (boardId && newName && boards[boardId]) {
      boards[boardId].name = newName;
      renderBoardTab(boardId, newName);
      closeSidebar();
      saveState();
    }
  };
}

// Event listener para seleção de arquivo de importação
importFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importFileName.textContent = file.name;
        btnImportConfirm.disabled = false;
    } else {
        importFileName.textContent = 'Nenhum arquivo selecionado';
        btnImportConfirm.disabled = true;
    }
});

// Event listener para confirmar importação
btnImportConfirm.addEventListener('click', () => {
    const file = importFileInput.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const state = JSON.parse(e.target.result);

            if (importOverwriteCheckbox.checked) {
                Object.keys(boards).forEach(boardId => {
                    closeBoard(boardId);
                });
            }

            boardIdCounter = state.nextBoardId || boardIdCounter;
            tabIdCounter = state.nextTabId || tabIdCounter;
            textFieldIdCounter = state.nextTextFieldId || textFieldIdCounter;
            listIdCounter = state.nextListId || listIdCounter;
            currentZoom = state.currentZoom || 100;
            setZoom(currentZoom);

            if (state.favorites) {
                favorites = state.favorites;
                saveFavorites();
            }

            if (state.drawingData) {
                drawingData = state.drawingData;
                localStorage.setItem('drawingData', JSON.stringify(drawingData));
            }

            if (state.boards) {
                Object.keys(state.boards).forEach(boardId => {
                    const savedBoard = state.boards[boardId];

                    if (!boards[boardId]) {
                        boards[boardId] = {
                            id: boardId,
                            name: savedBoard.name,
                            tabs: [],
                            textFields: [],
                            lists: [],
                            activeTabId: savedBoard.activeTabId,
                            activeTextFieldId: savedBoard.activeTextFieldId,
                            activeListId: savedBoard.activeListId
                        };
                        renderBoardTab(boardId, savedBoard.name);
                    }

                    if (savedBoard.tabs) {
                        savedBoard.tabs.forEach(savedTab => {
                            createTab(savedTab.url, savedTab, boardId);
                        });
                    }

                    if (savedBoard.textFields) {
                        savedBoard.textFields.forEach(savedTextField => {
                            createTextField(savedTextField, boardId);
                        });
                    }

                    if (savedBoard.lists) {
                        savedBoard.lists.forEach(savedList => {
                            createList(savedList, boardId);
                        });
                    }
                });
            }

            if (state.currentBoardId && boards[state.currentBoardId]) {
                switchBoard(state.currentBoardId, true);
            }

            importModal.style.display = 'none';
            saveState();

        } catch (error) {
            showMessage("Error in import file: " + error.message);
            console.error('Erro ao importar:', error);
        }
    };
    reader.readAsText(file);
});

// Event listener para salvar renomeação
btnSaveRename.addEventListener('click', () => {
    const boardId = renameBoardSelect.value;
    const newName = renameBoardInput.value.trim();

    if (boardId && newName && boards[boardId]) {
        boards[boardId].name = newName;
        renderBoardTab(boardId, newName);
        renameModal.style.display = 'none';
        saveState();
    }
});

// Event listeners para fechar modais
closeModalButtons.forEach(button => {
    button.addEventListener('click', () => {
        document.querySelectorAll('.modal-overlay').forEach(modal => {
            modal.style.display = 'none';
        });
    });
});

// Fechar modais ao clicar fora
window.addEventListener('click', (e) => {
    if (e.target.classList.contains('modal-overlay')) {
        e.target.style.display = 'none';
    }
});

// Atualizar input de nome quando selecionar outro board
renameBoardSelect.addEventListener('change', () => {
    if (renameBoardSelect.value && boards[renameBoardSelect.value]) {
        renameBoardInput.value = boards[renameBoardSelect.value].name;
    }
});

function saveState() {
    const state = {
        boards: {},
        currentBoardId,
        currentZoom,
        nextTabId: tabIdCounter,
        nextTextFieldId: textFieldIdCounter,
        nextListId: listIdCounter,
        nextBoardId: boardIdCounter,
        favorites: favorites,
        drawingData: drawingData
    };

    Object.keys(boards).forEach(boardId => {
        const board = boards[boardId];
        state.boards[boardId] = {
            id: board.id,
            name: board.name,
            activeTabId: board.activeTabId,
            activeTextFieldId: board.activeTextFieldId,
            activeListId: board.activeListId,
            tabs: board.tabs
                .filter(tab => !tab.anonima)  // Only include tabs where isAnonymous is false
                .map(tab => ({
                    id: tab.id,
                    url: tab.webview.src,
                    position: {
                        top: tab.tabFrame.style.top,
                        left: tab.tabFrame.style.left,
                        zIndex: tab.tabFrame.style.zIndex
                    },
                    size: {
                        width: tab.tabFrame.style.width,
                        height: tab.tabFrame.style.height
                    },
                    maximized: tab.tabFrame.classList.contains('maximized-tab')
                })),
            textFields: board.textFields.map(textField => ({
                id: textField.id,
                content: textField.textarea.value,
                title: textField.textFieldFrame.querySelector('.title-section').value,
                position: {
                    top: textField.textFieldFrame.style.top,
                    left: textField.textFieldFrame.style.left,
                    zIndex: textField.textFieldFrame.style.zIndex
                },
                size: {
                    width: textField.textFieldFrame.style.width,
                    height: textField.textFieldFrame.style.height
                },
                maximized: textField.textFieldFrame.classList.contains('maximized-textfield')
            })),
            lists: board.lists.map(list => ({
                id: list.id,
                title: list.listFrame.querySelector('.title-section').value,
                items: Array.from(list.listContent.querySelectorAll('.list-item')).map(item => ({
                    checked: item.querySelector('input[type="checkbox"]').checked,
                    text: item.querySelector('input[type="text"]').value
                })),
                position: {
                    top: list.listFrame.style.top,
                    left: list.listFrame.style.left,
                    zIndex: list.listFrame.style.zIndex
                },
                size: {
                    width: list.listFrame.style.width,
                    height: list.listFrame.style.height
                },
                maximized: list.listFrame.classList.contains('maximized-list')
            }))
        };
    });

    localStorage.setItem('browserState', JSON.stringify(state));
}
function loadState() {
    const savedState = localStorage.getItem('browserState');
    if (!savedState) {
        createBoard('Board 1', true);
        setZoom(100);
        return;
    }

    try {
        const state = JSON.parse(savedState);
        boardIdCounter = state.nextBoardId || 0;
        tabIdCounter = state.nextTabId || 0;
        textFieldIdCounter = state.nextTextFieldId || 0;
        listIdCounter = state.nextListId || 0;
        currentZoom = state.currentZoom || 100;
        setZoom(currentZoom);

        if (state.favorites) {
            favorites = state.favorites;
            saveFavorites();
        }

        if (state.drawingData) {
            drawingData = state.drawingData;
            localStorage.setItem('drawingData', JSON.stringify(drawingData));
        }

        if (state.boards) {
            Object.keys(state.boards).forEach(boardId => {
                const savedBoard = state.boards[boardId];
                boards[boardId] = {
                    id: boardId,
                    name: savedBoard.name,
                    tabs: [],
                    textFields: [],
                    lists: [],
                    activeTabId: savedBoard.activeTabId,
                    activeTextFieldId: savedBoard.activeTextFieldId,
                    activeListId: savedBoard.activeListId
                };
                renderBoardTab(boardId, savedBoard.name);
            });
        }

        if (state.boards) {
            Object.keys(state.boards).forEach(boardId => {
                const savedBoard = state.boards[boardId];

                if (savedBoard.tabs) {
                    savedBoard.tabs.forEach(savedTab => {
                        createTab(savedTab.url, savedTab, boardId);
                    });
                }

                if (savedBoard.textFields) {
                    savedBoard.textFields.forEach(savedTextField => {
                        createTextField(savedTextField, boardId);
                    });
                }

                if (savedBoard.lists) {
                    savedBoard.lists.forEach(savedList => {
                        createList(savedList, boardId);
                    });
                }
            });
        }

        if (state.currentBoardId && boards[state.currentBoardId]) {
            switchBoard(state.currentBoardId, true);
        } else {
            const firstBoardId = Object.keys(boards)[0];
            if (firstBoardId) switchBoard(firstBoardId, true);
        }
    } catch (e) {
        console.error('Erro ao carregar estado:', e);
        createBoard('Board 1', true);
        setZoom(100);
    }
}

function createBoard(name, isInitial = false) {
    const id = `board-${++boardIdCounter}`;
    boards[id] = {
        id,
        name,
        tabs: [],
        textFields: [],
        lists: [],
        activeTabId: null,
        activeTextFieldId: null,
        activeListId: null
    };

    renderBoardTab(id, name);

    if (isInitial || !currentBoardId) {
        switchBoard(id, true);
    }

    saveState();
    return id;
}

function renderBoardTab(boardId, boardName) {
    const existingTab = document.querySelector(`.board-tab[data-board-id="${boardId}"]`);
    if (existingTab) {
        existingTab.remove();
    }

    const boardTab = document.createElement('button');
    boardTab.classList.add('board-tab');
    boardTab.dataset.boardId = boardId;
    boardTab.title = boardName;
    boardTab.textContent = boardName;
    boardTab.draggable = true;

    if (currentBoardId === boardId) {
        boardTab.classList.add('active');
    }

    boardTab.addEventListener('click', () => {
        switchBoard(boardId);
    });

    const closeBtn = document.createElement('span');
    closeBtn.innerHTML = ' &times;';
    closeBtn.style.marginLeft = '5px';
    closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        closeBoard(boardId);
    });
    boardTab.appendChild(closeBtn);

    boardsContainer.appendChild(boardTab);
}

function switchBoard(boardId, initialLoad = false) {
    if (!boards[boardId] || currentBoardId === boardId) return;

    if (currentBoardId && boards[currentBoardId]) {
        const currentBoard = boards[currentBoardId];
        currentBoard.tabs.forEach(tab => {
            tab.tabFrame.style.display = 'none';
        });
        currentBoard.textFields.forEach(textField => {
            textField.textFieldFrame.style.display = 'none';
        });
        currentBoard.lists.forEach(list => {
            list.listFrame.style.display = 'none';
        });
    }

    currentBoardId = boardId;
    const board = boards[boardId];

    board.tabs.forEach(tab => {
        tab.tabFrame.style.display = 'flex';
    });
    board.textFields.forEach(textField => {
        textField.textFieldFrame.style.display = 'flex';
    });
    board.lists.forEach(list => {
        list.listFrame.style.display = 'flex';
    });

    document.querySelectorAll('.board-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`.board-tab[data-board-id="${boardId}"]`).classList.add('active');

    activeTabId = board.activeTabId;
    activeTextFieldId = board.activeTextFieldId;
    activeListId = board.activeListId;

    resizeCanvas();
    loadDrawing();

    if (!initialLoad) {
        saveState();
    }
}

function closeBoard(boardId) {
    if (Object.keys(boards).length <= 1) {
        showMessage("You cannot close the last board.");
        return;
    }

    const board = boards[boardId];
    if (!board) return;

    board.tabs.forEach(tab => {
        tab.tabFrame.remove();
    });
    board.textFields.forEach(textField => {
        textField.textFieldFrame.remove();
    });
    board.lists.forEach(list => {
        list.listFrame.remove();
    });

    delete boards[boardId];

    const boardTab = document.querySelector(`.board-tab[data-board-id="${boardId}"]`);
    if (boardTab) boardTab.remove();

    if (currentBoardId === boardId) {
        const remainingBoardId = Object.keys(boards)[0];
        if (remainingBoardId) {
            switchBoard(remainingBoardId);
        } else {
            createBoard('Board 1', true);
        }
    }

    saveState();
}

function createTabAnonima(url = defaultStartPage, savedState = null, targetBoardId = null){
    const boardId = targetBoardId || currentBoardId;
    if (!boardId || !boards[boardId]) return;

    const id = savedState ? savedState.id : ++tabIdCounter;
    if (!savedState) tabIdCounter = Math.max(tabIdCounter, id);

    const tabFrame = document.createElement('div');
    tabFrame.classList.add('tab-frame');

    if (savedState) {
        tabFrame.style.top = savedState.position.top || '50px';
        tabFrame.style.left = savedState.position.left || '50px';
        tabFrame.style.zIndex = savedState.position.zIndex || (100 + id);
        tabFrame.style.width = '600px';
        tabFrame.style.height = '400px';
        if (savedState.maximized) {
            //tabFrame.classList.add('maximized-tab');
        }
    } else {
        tabFrame.style.top = '50px';
        tabFrame.style.left = (50 + boards[boardId].tabs.length * 30) + 'px';
        tabFrame.style.zIndex = 100 + id;
        tabFrame.style.width = '600px';
        tabFrame.style.height = '400px';
    }

    tabFrame.dataset.id = id;

    const header = document.createElement('div');
    header.classList.add('tab-header');
    header.innerHTML = `
    <div class="url-section">
    <input type="url" placeholder="Input the URL or Search..." />
    <div class="suggestions-box"></div>
    </div>
    <div class="controls">
    <button title="Ad Blocker" class="btn-ad-blocker">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shield-icon lucide-shield"><path d="M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"/></svg>
    </button>
    <button title="Copy Elements" class="btn-copy-elements">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy-icon lucide-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
    </button>
    <button title="Edit as HTML" class="btn-edit-html">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code-xml-icon lucide-code-xml"><path d="m18 16 4-4-4-4"/><path d="m6 8-4 4 4 4"/><path d="m14.5 4-5 16"/></svg>
    </button>
    <button title="Back" class="btn-back">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-reply-icon lucide-reply"><path d="M20 18v-2a4 4 0 0 0-4-4H4"/><path d="m9 17-5-5 5-5"/></svg>
    </button>
    <button title="Forward" class="btn-forward">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-forward-icon lucide-forward"><path d="m15 17 5-5-5-5"/><path d="M4 18v-2a4 4 0 0 1 4-4h12"/></svg>
    </button>
    <button title="Refresh" class="btn-refresh">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rotate-ccw-icon lucide-rotate-ccw"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
    </button>
    <button title="Pin/Unpin" class="btn-pin">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>
    </button>
    <div class="move-to-board-container">
    <button class="btn-move-to-board" title="Move to another board">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move3d-icon lucide-move-3d"><path d="M5 3v16h16"/><path d="m5 19 6-6"/><path d="m2 6 3-3 3 3"/><path d="m18 16 3 3-3 3"/></svg>
    </button>
    <div class="move-to-board-menu"></div>
    </div>
    <button title="Change size" class="btn-maximize"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2-icon lucide-maximize-2"><path d="M15 3h6v6"/><path d="m21 3-7 7"/><path d="m3 21 7-7"/><path d="M9 21H3v-6"/></svg>
    </button>
    <button title="Close" class="btn-close"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
    </button>
    </div>
    `;

    tabFrame.appendChild(header);

    const content = document.createElement('div');
    content.classList.add('tab-content');

    const webview = document.createElement('webview');
    

    let isAdBlockerActive = false;
    const btnCopyElements = header.querySelector('.btn-copy-elements');

    function removeBlankTargets() {
        return `
        (function() {
            function removeBlankTargetsFromLinks() {
                const links = document.querySelectorAll('a[target="_blank"]');
                links.forEach(link => {
                    link.removeAttribute('target');
                });
            }

            // Executa imediatamente
            removeBlankTargetsFromLinks();
            
            // Observa mudanças no DOM para links dinâmicos
            const observer = new MutationObserver(removeBlankTargetsFromLinks);
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        })();
        `;
    }


    const getAdBlockRules = () => {
    return `
    (function() {
        const adSelectors = [
            // Seletores gerais de anúncios
            '[class*="ad-"]', '[class*="ads-"]', '[class*="advertisement"]',
            '[id*="ad-"]', '[id*="ads-"]', '[id*="advertisement"]',
            '.ad', '.ads', '.advertisement', '.banner', '.popup',
            '[class*="-ad"]', '[id*="-ad"]', // Para padrões como "mid-ad", "right-ad"
            '.ad-unit', '.ad-placeholder', '.ad-label',
            '.ad-slot', '.ad-area', '.ad-zone',
            '.advert', '.advertising', '.ad-container',
            '.ad-wrapper', '.ad-banner', '.ad-box',
            '.ad-link', '.ad-text', '.ad-image',
            '.advertorial', '.sponsored-post', '.promoted-content',
            '.paid-content', '.ad-wall', '.ad-sticky',
            '.ad-popup', '.ad-overlay', '.ad-interstitial',
            // Redes de anúncios específicas
            '.taboola', '.outbrain', '.revcontent',
            '.adform', '.adtech', '.doubleclick',
            '.google-ads', '.adsense', '.adchoices',
            // Elementos de vídeo
            '.video-ads', '.preroll', '.midroll',
            '.postroll', '.ad-break', '.ad-skip',
            
            // Seletores específicos para sites de notícias
            '.adsbygoogle', '.google-ads', '.googlesyndication',
            '.ad-container', '.ad-wrapper', '.ad-banner', '.ad-slot',
            '.sponsored', '.sponsored-content', '.promotion',
            'adservice.google.com', 'pagead2.googlesyndication.com',
            'securepubads.g.doubleclick.net', 'ads.pubmatic.com',
            'adsrvr.org', 'criteo.com', 'adnxs.com',
            'amazon-adsystem.com', 'adsystem.com', 'advertising.com',
            'adroll.com', 'zemanta.com', 'quantserve.com',
            'scorecardresearch.com', 'rlcdn.com', 'bluekai.com',
            'agkn.com', 'mathtag.com', 'tapad.com',
            'advertising.amazon.com', 'ads.yahoo.com', 'ads.bing.com',
            'ads.facebook.com', 'an.yandex.ru', 'ads.tiktok.com',
            'ads.twitter.com', 'ads.linkedin.com', 'ads.reddit.com',
            
            // YouTube específico
            '.ytp-ad-module', '.video-ads', '.ytp-ad-overlay-container',
            '.ytp-ad-text-overlay', '.ytp-ad-player-overlay',
            '.masthead-ad-control', '.ytd-promoted-sparkles-web-renderer',
            '.ytd-compact-promoted-video-renderer', '.ytd-promoted-video-renderer',
            '.ytd-display-ad-renderer', '.ytd-video-masthead-ad-advertiser-info-renderer',
            
            // Outros sites comuns
            '.sidebar-ad', '.header-ad', '.footer-ad', '.inline-ad',
            '.native-ad', '.content-ad', '.video-ad', '.display-ad',
            '.square-ad', '.leaderboard-ad', '.skyscraper-ad',
            
            // Termos em outros idiomas
            '[class*="publicidade"]', '[class*="anuncio"]', '[class*="reclame"]',
            '[id*="publicidade"]', '[id*="anuncio"]', '[id*="reclame"]'
        ];
        
        const adDomains = [
            'googlesyndication.com', 'googleadservices.com', 'doubleclick.net',
            'googletagmanager.com', 'google-analytics.com', 'googletagservices.com',
            'facebook.com/tr', 'connect.facebook.net', 'amazon-adsystem.com',
            'adsystem.amazon.com', 'outbrain.com', 'taboola.com',
            'criteo.com', 'adsrvr.org', 'rubiconproject.com',
            'pubmatic.com', 'openx.com', 'adsafeprotected.com'
        ];
        
        function removeAds() {
            // Remove elementos por seletores
            adSelectors.forEach(selector => {
                try {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        el.style.display = 'none !important';
                        el.style.visibility = 'hidden !important';
                        el.style.opacity = '0 !important';
                        el.style.height = '0 !important';
                        el.style.width = '0 !important';
                    });
                } catch(e) {}
            });
            
            // Remove iframes e scripts de anúncios
            const iframes = document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                if (iframe.src) {
                    const src = iframe.src.toLowerCase();
                    if (adDomains.some(domain => src.includes(domain)) || 
                        src.includes('ad') || src.includes('banner') || src.includes('popup')) {
                        iframe.style.display = 'none !important';
                        iframe.remove();
                    }
                }
            });
            
            // Remove scripts de anúncios
            const scripts = document.querySelectorAll('script');
            scripts.forEach(script => {
                if (script.src) {
                    const src = script.src.toLowerCase();
                    if (adDomains.some(domain => src.includes(domain))) {
                        script.remove();
                    }
                }
            });
            
            // YouTube específico - remove anúncios em vídeos
            const ytAds = document.querySelectorAll('.ytp-ad-skip-button, .ytp-ad-skip-button-modern');
            ytAds.forEach(skipBtn => {
                if (skipBtn.style.display !== 'none') {
                    skipBtn.click();
                }
            });
            
            // Remove overlay de anúncios
            const overlays = document.querySelectorAll('[class*="overlay"]');
            overlays.forEach(overlay => {
                const text = overlay.textContent.toLowerCase();
                if (text.includes('ad') || text.includes('anúncio') || text.includes('publicidade')) {
                    overlay.style.display = 'none !important';
                }
            });
        }
        
        // Executa imediatamente
        removeAds();
        
        // Observa mudanças no DOM
        const observer = new MutationObserver(() => {
            removeAds();
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class', 'id', 'src']
        });
        
        // Executa periodicamente para pegar anúncios dinâmicos
        setInterval(removeAds, 2000);
        
        // Bloqueia requisições de anúncios
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            const url = args[0];
            if (typeof url === 'string' && adDomains.some(domain => url.includes(domain))) {
                return Promise.reject(new Error('Blocked by ad blocker'));
            }
            return originalFetch.apply(this, args);
        };
        
        // Bloqueia XMLHttpRequest de anúncios
        const originalXHR = window.XMLHttpRequest.prototype.open;
        window.XMLHttpRequest.prototype.open = function(method, url) {
            if (typeof url === 'string' && adDomains.some(domain => url.includes(domain))) {
                return;
            }
            return originalXHR.apply(this, arguments);
        };
        
        console.log('Ad Blocker ativado');
    })();
    `;
};

webview.addEventListener('did-finish-load', () => {
    webview.executeJavaScript(removeBlankTargets()).catch(err => {
        console.error('Failed to remove blank targets:', err);
    });
});

const btnAdBlocker = header.querySelector('.btn-ad-blocker');

// Event listener para o botão de ad blocker
btnAdBlocker.addEventListener('click', (e) => {
    e.stopPropagation();
    isAdBlockerActive = !isAdBlockerActive;
    btnAdBlocker.classList.toggle('active');
    
    try {
        if (isAdBlockerActive) {
            // Ativa o ad blocker
            webview.executeJavaScript(getAdBlockRules()).catch(err => {
                console.error('Failed to activate ad blocker:', err);
                isAdBlockerActive = false;
                btnAdBlocker.classList.remove('active');
            });
            
            btnAdBlocker.title = 'Disable Ad Blocker';
            btnAdBlocker.style.color = '#4CAF50';
            webview.reload();
        } else {
            // Desativa o ad blocker (recarrega a página)
            webview.reload();
            btnAdBlocker.title = 'Ad Blocker';
            btnAdBlocker.style.color = '';
        }
    } catch (err) {
        console.error('Error toggling ad blocker:', err);
        isAdBlockerActive = false;
        btnAdBlocker.classList.remove('active');
    }
});



    // Event listener para o botão de cópia - CORRIGIDO
    btnCopyElements.addEventListener('click', (e) => {
        e.stopPropagation();
        isCopyModeActive = !isCopyModeActive;
        btnCopyElements.classList.toggle('active');

        try {
            if (isCopyModeActive) {
                // Ativando modo cópia
                webview.executeJavaScript(`
                try {
                    // Limpa qualquer listener anterior
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }

                    // Define o novo handler
                    function copyModeHandler(e) {
    e.preventDefault();
    e.stopPropagation();

    let textToCopy = '';
    if (e.target.href) {
        textToCopy = e.target.href;
    } else if (e.target.src) {
        textToCopy = e.target.src;
    } else {
        const selection = window.getSelection();
        if (selection && selection.toString().trim() !== '') {
            textToCopy = selection.toString();
        } else {
            return;
        }
    }

    // Método moderno com fallback
    if (navigator.clipboard) {
        navigator.clipboard.writeText(textToCopy).then(() => {
            console.log('Copied to clipboard:', textToCopy);
            window.postMessage({ type: 'copyCompleted' }, '*');
        }).catch(err => {
            // Fallback para método antigo se o moderno falhar
            fallbackCopyTextToClipboard(textToCopy);
        });
    } else {
        fallbackCopyTextToClipboard(textToCopy);
    }
}


                    // Armazena o handler globalmente e adiciona o listener
                    window.copyModeHandler = copyModeHandler;
                    document.body.addEventListener('click', copyModeHandler, true);

                    // Muda o cursor para indicar modo cópia
                    document.body.style.cursor = 'copy';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = 'copy';
                    });

                } catch(e) {
                    console.error('Error activating copy mode:', e);
                }
                `).catch(err => {
                    console.error('Failed to activate copy mode:', err);
                    isCopyModeActive = false;
                    btnCopyElements.classList.remove('active');
                });

                //alert('Modo de cópia ativado. Clique em qualquer elemento para copiar seu conteúdo.');

            } else {
                // Desativando modo cópia
                webview.executeJavaScript(`
                try {
                    // Remove o event listener do modo cópia
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }

                    // Restaura o cursor padrão
                    document.body.style.cursor = '';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = '';
                    });

                } catch(e) {
                    console.error('Error deactivating copy mode:', e);
                }
                `).catch(err => {
                    console.error('Failed to deactivate copy mode:', err);
                });

                //alert('Modo de cópia desativado!');
            }

        } catch (err) {
            console.error('Error toggling copy mode:', err);
            isCopyModeActive = false;
            btnCopyElements.classList.remove('active');
        }
    });

    // Listener para quando a cópia for completada
    window.addEventListener('message', (e) => {
        if (e.data.type === 'copyCompleted') {
            isCopyModeActive = false;
            btnCopyElements.classList.remove('active');

            try {
                webview.executeJavaScript(`
                try {
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }
                    document.body.style.cursor = '';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = '';
                    });
                } catch(e) {
                    console.error('Error cleaning up copy mode after completion:', e);
                }
                `).catch(err => {
                    console.error('Failed to clean up copy mode after completion:', err);
                });
            } catch (err) {
                console.error('Error cleaning up copy mode after completion:', err);
            }
        }
    });

    webview.src = savedState ? savedState.url : url;
    webview.setAttribute('allowpopups', '');
    webview.setAttribute('partition', 'anon_' + Date.now());
    
    

    webview.setAttribute('webpreferences', 'clipboard-read=yes, clipboard-write=yes');
    webview.style.background = 'white';

    const applyChromeUserAgentIfNeeded = (currentUrl) => {
        if (currentUrl.includes('web.whatsapp.com')) {
            webview.setAttribute('useragent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36');
        } else {
            webview.removeAttribute('useragent'); // Volta ao user-agent padrão
        }
    };

    // Aplica no carregamento inicial
    applyChromeUserAgentIfNeeded(savedState ? savedState.url : url);

    // Monitora alterações de URL (navegação dentro do webview)
    webview.addEventListener('did-navigate', (e) => {
        applyChromeUserAgentIfNeeded(e.url);
        addToHistory(e.url);

        if (isAdBlockerActive) {
            setTimeout(() => {
                webview.executeJavaScript(getAdBlockRules()).catch(err => {
                    console.error('Failed to reapply ad blocker after navigation:', err);
                });
            }, 1000);
        }

    });

    // Monitora redirecionamentos (como após login)
    webview.addEventListener('did-navigate-in-page', (e) => {
        if (e.isMainFrame) {
            applyChromeUserAgentIfNeeded(e.url);
        }

        if (isAdBlockerActive) {
            setTimeout(() => {
                webview.executeJavaScript(getAdBlockRules()).catch(err => {
                    console.error('Failed to reapply ad blocker after in-page navigation:', err);
                });
            }, 1000);
        }
    });

    content.appendChild(webview);
    tabFrame.appendChild(content);

    addResizers(tabFrame);

    desktop.appendChild(tabFrame);

    const urlInput = header.querySelector('input[type="url"]');

    const suggestionsBox = header.querySelector('.suggestions-box');

    urlInput.addEventListener('input', (e) => {
        const inputText = e.target.value.toLowerCase().trim();
        suggestionsBox.innerHTML = '';

        if (inputText.length === 0) {
            suggestionsBox.style.display = 'none';
            return;
        }

        // Combina histórico e favoritos em uma única lista, sem duplicatas
        const favoriteUrls = favorites.map(fav => fav.url);
        const allSources = [...new Set([...browsingHistory, ...favoriteUrls])];

        const filtered = allSources.filter(item => item.toLowerCase().includes(inputText));

        // Limita a 10 sugestões para não poluir a tela
        const topResults = filtered.slice(0, 10);

        if (topResults.length > 0) {
            topResults.forEach(suggestionUrl => {
                const item = document.createElement('div');
                item.classList.add('suggestion-item');
                item.textContent = suggestionUrl;
                item.title = suggestionUrl; // Mostra URL completa no hover

                // Evento de clique em uma sugestão
                item.addEventListener('mousedown', (event) => {
                    event.preventDefault(); // Previne que o input perca o foco antes do clique
                    urlInput.value = suggestionUrl;
                    webview.src = suggestionUrl;
                    suggestionsBox.style.display = 'none';
                    saveState();
                });

                suggestionsBox.appendChild(item);
            });
            suggestionsBox.style.display = 'block';
        } else {
            suggestionsBox.style.display = 'none';
        }
    });

    // Esconde a caixa de sugestões quando o input perde o foco
    urlInput.addEventListener('blur', () => {
        // Usamos um pequeno timeout para permitir que o clique no item de sugestão seja registrado
        setTimeout(() => {
            suggestionsBox.style.display = 'none';
        }, 150);
    });

    // Mostra a caixa de sugestões quando o input ganha foco e já tem texto
    urlInput.addEventListener('focus', () => {
        if (urlInput.value.trim().length > 0) {
            // Dispara o evento 'input' para re-filtrar e mostrar as sugestões
            urlInput.dispatchEvent(new Event('input'));
        }
    });
    // **FIM DA LÓGICA DE SUGESTÕES**

    const btnMaximize = header.querySelector('.btn-maximize');
    const btnClose = header.querySelector('.btn-close');
    const btnMoveToBoard = header.querySelector('.btn-move-to-board');
    const moveToBoardMenu = header.querySelector('.move-to-board-menu');
    const goBackBtn = header.querySelector('.btn-back');
    const goForwardBtn = header.querySelector('.btn-forward');
    const refreshBtn = header.querySelector('.btn-refresh');
    const pinBtn = header.querySelector('.btn-pin');
    const btnEditHtml = header.querySelector('.btn-edit-html');

    btnEditHtml.addEventListener('click', async (e) => {
        e.stopPropagation();

        try {
            // Obtém o HTML da página atual
            const html = await webview.executeJavaScript(`
            document.documentElement.outerHTML
            `);

            // Cria um novo campo de texto com o HTML
            const textFieldId = createTextField({
                content: html,
                title: `HTML Export: ${webview.getTitle() || 'Untitled'}`,
                                                position: {
                                                    top: '100px',
                                                    left: '100px',
                                                    zIndex: 200 + textFieldIdCounter
                                                },
                                                size: {
                                                    width: '800px',
                                                    height: '600px'
                                                }
            }, currentBoardId);

            // Adiciona um listener para atualizar o webview quando o texto for alterado
            const textField = boards[currentBoardId].textFields.find(t => t.id === textFieldId);
            const textarea = textField.textarea;

            textarea.addEventListener('input', () => {
                try {
                    // Atualiza o webview com o novo HTML
                    webview.executeJavaScript(`
                    document.open();
                    document.write(\`${textarea.value.replace(/`/g, '\\`')}\`);
                    document.close();
                    `);
                } catch (error) {
                    console.error('Error updating webview:', error);
                }
            });

        } catch (error) {
            console.error('Error exporting HTML:', error);
            showMessage('Failed to export HTML. The page may have restrictions.');
        }
    });

    function updatePinButton() {
        if (isFavorite(webview.src)) {
            pinBtn.classList.add('pinned');
            pinBtn.title = 'Unpin from favorites';
        } else {
            pinBtn.classList.remove('pinned');
            pinBtn.title = 'Pin to favorites';
        }
    }

    pinBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const url = webview.src;

        if (isFavorite(url)) {
            removeFavorite(url);
        } else {
            addFavorite(url, document.title || new URL(url).hostname);
        }

        updatePinButton();
    });

    webview.addEventListener('did-navigate', (e) => {
        urlInput.value = e.url;
        updatePinButton();
    });

    webview.addEventListener('page-title-updated', (e) => {
        if (isFavorite(webview.src)) {
            const favIndex = favorites.findIndex(fav => fav.url === webview.src);
            if (favIndex !== -1) {
                favorites[favIndex].title = e.title;
                saveFavorites();
                updateFavoritesGrid();
            }
        }
    });

    function updateMoveToBoardMenu() {
        moveToBoardMenu.innerHTML = '';

        Object.keys(boards).forEach(targetBoardId => {
            if (targetBoardId !== boardId) {
                const button = document.createElement('button');
                button.textContent = boards[targetBoardId].name;
                button.addEventListener('click', () => {
                    moveItemToBoard('tab', id, targetBoardId);
                });
                moveToBoardMenu.appendChild(button);
            }
        });
    }

    btnMoveToBoard.addEventListener('click', (e) => {
        e.stopPropagation();
        updateMoveToBoardMenu();
        moveToBoardMenu.style.display = moveToBoardMenu.style.display === 'block' ? 'none' : 'block';
    });

    document.addEventListener('click', (e) => {
        if (!header.contains(e.target)) {
            moveToBoardMenu.style.display = 'none';
        }
    });

    makeDraggable(tabFrame, header);

    // Event listener principal do tabFrame - CORRIGIDO
    tabFrame.addEventListener('click', (e) => {
        // Verifica se o clique foi no botão de cópia - se sim, não desativa
        if (e.target.closest('.btn-copy-elements')) {
            return;
        }

        // Se o modo cópia estiver ativo e o clique não foi no botão, desativa
        if (isCopyModeActive) {
            isCopyModeActive = false;
            btnCopyElements.classList.remove('active');

            try {
                webview.executeJavaScript(`
                try {
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }
                    document.body.style.cursor = '';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = '';
                    });
                } catch(e) {
                    console.error('Error disabling copy mode from tab click:', e);
                }
                `).catch(err => {
                    console.error('Failed to disable copy mode from tab click:', err);
                });
            } catch (err) {
                console.error('Error disabling copy mode from tab click:', err);
            }
            return;
        }

        // Resto da lógica original do clique no tab...
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.classList.contains('resizer')) return;

        removeAllFocus();
        tabFrame.classList.add('focused');
        urlInput.style.display = 'block';
        urlInput.value = webview.src || url;
        urlInput.focus();
        urlInput.select();

        boards[boardId].activeTabId = id;
        boards[boardId].activeTextFieldId = null;
        boards[boardId].activeListId = null;
        activeTabId = id;
        activeTextFieldId = null;
        activeListId = null;

        saveState();
    });

    urlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            let newUrl = urlInput.value.trim();
            if (newUrl && !newUrl.includes('.') && !newUrl.startsWith('http')) {
                switch (defaultSearchEngine) {
                    case 'google':
                        newUrl = `https://www.google.com/search?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'duckduckgo':
                        newUrl = `https://duckduckgo.com/?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'bing':
                        newUrl = `https://www.bing.com/search?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'perplexity':
                        newUrl = `https://www.perplexity.ai/?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'chatgpt':
                        newUrl = `https://chatgpt.com/?q=${encodeURIComponent(newUrl)}`;
                        break;
                }
            } else if (!newUrl.startsWith('http')) {
                newUrl = 'https://' + newUrl;
            }

            if (newUrl) {
                webview.src = newUrl;
                tabFrame.classList.remove('focused');
                saveState();
            }
        }
    });

    urlInput.addEventListener('blur', () => {
        setTimeout(() => {
            tabFrame.classList.remove('focused');
        }, 100);
    });

    btnClose.addEventListener('click', (e) => {
        e.stopPropagation();
        
        // Animação de explosão
        const tabRect = tabFrame.getBoundingClientRect();
        const centerX = tabRect.left + tabRect.width / 2;
        const centerY = tabRect.top + tabRect.height / 2;
        
        // Aplica animação de explosão no frame
        tabFrame.style.transformOrigin = 'center';
        tabFrame.style.animation = 'explode 0.3s ease-out forwards';
        
        // Cria partículas de fumaça
        for (let i = 0; i < 15; i++) {
            createSmokeParticle(centerX, centerY);
        }
        
        // Remove o frame após a animação
        setTimeout(() => {
            tabFrame.remove();
            
            // Remove a aba da lista de abas do board
            const board = boards[boardId];
            board.tabs = board.tabs.filter(tab => tab.id !== id);
            
            if (activeTabId === id) {
            activeTabId = null;
            board.activeTabId = null;
            }
            
            saveState();
        }, 300);
    });

    refreshBtn.addEventListener('click', (e) => {
        webview.reload();
    });

    goForwardBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        try {
            if(webview.canGoForward()){
                webview.goForward();
            }
        } catch(error) {}
    });

    goBackBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        try {
            if(webview.canGoBack()){
                webview.goBack();
            }
        } catch(error) {}
    });

    btnMaximize.addEventListener('click', (e) => {
        e.stopPropagation();
        const tab = boards[boardId].tabs.find(t => t.id === id);
        if (tab.tabFrame.classList.contains('maximized-tab')) {
            tab.tabFrame.classList.remove('maximized-tab');
            tab.tabFrame.style.top = savedState?.position?.top || '50px';
            tab.tabFrame.style.left = savedState?.position?.left || '50px';
            tab.tabFrame.style.width = '600px';
            tab.tabFrame.style.height = '400px';
            tab.tabFrame.style.borderRadius = '8px';
            tab.tabFrame.style.boxShadow = '0 0 15px rgba(0,0,0,0.7)';
            tab.tabFrame.style.zIndex = savedState?.position?.zIndex || (100 + id);
        } else {
            maximizeTab(id);
        }
        saveState();
    });

    tabFrame.addEventListener('wheel', e => {
        if (e.ctrlKey) {
            e.preventDefault();
            let zoom = webview.getZoomFactor();
            zoom += e.deltaY * -0.0015;
            zoom = Math.min(Math.max(zoom, 0.25), 3);
            webview.setZoomFactor(zoom);
        }
    });

    boards[boardId].tabs.push({ id, tabFrame, webview, minimized: false, url: savedState ? savedState.url : url, anonima: true });

    if (savedState?.maximized) {
        maximizeTab(id);
    }

    if (boardId !== currentBoardId) {
        tabFrame.style.display = 'none';
    }

    updatePinButton();

    return id;
}


function createTab(url = defaultStartPage, savedState = null, targetBoardId = null){
    const boardId = targetBoardId || currentBoardId;
    if (!boardId || !boards[boardId]) return;

    const id = savedState ? savedState.id : ++tabIdCounter;
    if (!savedState) tabIdCounter = Math.max(tabIdCounter, id);

    const tabFrame = document.createElement('div');
    tabFrame.classList.add('tab-frame');

    if (savedState) {
        tabFrame.style.top = savedState.position.top || '50px';
        tabFrame.style.left = savedState.position.left || '50px';
        tabFrame.style.zIndex = savedState.position.zIndex || (100 + id);
        tabFrame.style.width = '600px';
        tabFrame.style.height = '400px';
        if (savedState.maximized) {
            //tabFrame.classList.add('maximized-tab');
        }
    } else {
        tabFrame.style.top = '50px';
        tabFrame.style.left = (50 + boards[boardId].tabs.length * 30) + 'px';
        tabFrame.style.zIndex = 100 + id;
        tabFrame.style.width = '600px';
        tabFrame.style.height = '400px';
    }

    tabFrame.dataset.id = id;

    const header = document.createElement('div');
    header.classList.add('tab-header');
    header.innerHTML = `
    <div class="url-section">
    <input type="url" placeholder="Input the URL or Search..." />
    <div class="suggestions-box"></div>
    </div>
    <div class="controls">
    <button title="Ad Blocker" class="btn-ad-blocker">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-shield-icon lucide-shield"><path d="M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"/></svg>
    </button>
    <button title="Copy Elements" class="btn-copy-elements">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy-icon lucide-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
    </button>
    <button title="Edit as HTML" class="btn-edit-html">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code-xml-icon lucide-code-xml"><path d="m18 16 4-4-4-4"/><path d="m6 8-4 4 4 4"/><path d="m14.5 4-5 16"/></svg>
    </button>
    <button title="Back" class="btn-back">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-reply-icon lucide-reply"><path d="M20 18v-2a4 4 0 0 0-4-4H4"/><path d="m9 17-5-5 5-5"/></svg>
    </button>
    <button title="Forward" class="btn-forward">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-forward-icon lucide-forward"><path d="m15 17 5-5-5-5"/><path d="M4 18v-2a4 4 0 0 1 4-4h12"/></svg>
    </button>
    <button title="Refresh" class="btn-refresh">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rotate-ccw-icon lucide-rotate-ccw"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
    </button>
    <button title="Pin/Unpin" class="btn-pin">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>
    </button>
    <div class="move-to-board-container">
    <button class="btn-move-to-board" title="Move to another board">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move3d-icon lucide-move-3d"><path d="M5 3v16h16"/><path d="m5 19 6-6"/><path d="m2 6 3-3 3 3"/><path d="m18 16 3 3-3 3"/></svg>
    </button>
    <div class="move-to-board-menu"></div>
    </div>
    <button title="Change size" class="btn-maximize"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2-icon lucide-maximize-2"><path d="M15 3h6v6"/><path d="m21 3-7 7"/><path d="m3 21 7-7"/><path d="M9 21H3v-6"/></svg>
    </button>
    <button title="Close" class="btn-close"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
    </button>
    </div>
    `;

    tabFrame.appendChild(header);

    const content = document.createElement('div');
    content.classList.add('tab-content');

    const webview = document.createElement('webview');
    

    let isAdBlockerActive = false;
    const btnCopyElements = header.querySelector('.btn-copy-elements');

    function removeBlankTargets() {
        return `
        (function() {
            function removeBlankTargetsFromLinks() {
                const links = document.querySelectorAll('a[target="_blank"]');
                links.forEach(link => {
                    link.removeAttribute('target');
                });
            }

            // Executa imediatamente
            removeBlankTargetsFromLinks();
            
            // Observa mudanças no DOM para links dinâmicos
            const observer = new MutationObserver(removeBlankTargetsFromLinks);
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        })();
        `;
    }


    const getAdBlockRules = () => {
    return `
    (function() {
        const adSelectors = [
            // Seletores gerais de anúncios
            '[class*="ad-"]', '[class*="ads-"]', '[class*="advertisement"]',
            '[id*="ad-"]', '[id*="ads-"]', '[id*="advertisement"]',
            '.ad', '.ads', '.advertisement', '.banner', '.popup',
            '[class*="-ad"]', '[id*="-ad"]', // Para padrões como "mid-ad", "right-ad"
            '.ad-unit', '.ad-placeholder', '.ad-label',
            '.ad-slot', '.ad-area', '.ad-zone',
            '.advert', '.advertising', '.ad-container',
            '.ad-wrapper', '.ad-banner', '.ad-box',
            '.ad-link', '.ad-text', '.ad-image',
            '.advertorial', '.sponsored-post', '.promoted-content',
            '.paid-content', '.ad-wall', '.ad-sticky',
            '.ad-popup', '.ad-overlay', '.ad-interstitial',
            // Redes de anúncios específicas
            '.taboola', '.outbrain', '.revcontent',
            '.adform', '.adtech', '.doubleclick',
            '.google-ads', '.adsense', '.adchoices',
            // Elementos de vídeo
            '.video-ads', '.preroll', '.midroll',
            '.postroll', '.ad-break', '.ad-skip',
            
            // Seletores específicos para sites de notícias
            '.adsbygoogle', '.google-ads', '.googlesyndication',
            '.ad-container', '.ad-wrapper', '.ad-banner', '.ad-slot',
            '.sponsored', '.sponsored-content', '.promotion',
            'adservice.google.com', 'pagead2.googlesyndication.com',
            'securepubads.g.doubleclick.net', 'ads.pubmatic.com',
            'adsrvr.org', 'criteo.com', 'adnxs.com',
            'amazon-adsystem.com', 'adsystem.com', 'advertising.com',
            'adroll.com', 'zemanta.com', 'quantserve.com',
            'scorecardresearch.com', 'rlcdn.com', 'bluekai.com',
            'agkn.com', 'mathtag.com', 'tapad.com',
            'advertising.amazon.com', 'ads.yahoo.com', 'ads.bing.com',
            'ads.facebook.com', 'an.yandex.ru', 'ads.tiktok.com',
            'ads.twitter.com', 'ads.linkedin.com', 'ads.reddit.com',
            
            // YouTube específico
            '.ytp-ad-module', '.video-ads', '.ytp-ad-overlay-container',
            '.ytp-ad-text-overlay', '.ytp-ad-player-overlay',
            '.masthead-ad-control', '.ytd-promoted-sparkles-web-renderer',
            '.ytd-compact-promoted-video-renderer', '.ytd-promoted-video-renderer',
            '.ytd-display-ad-renderer', '.ytd-video-masthead-ad-advertiser-info-renderer',
            
            // Outros sites comuns
            '.sidebar-ad', '.header-ad', '.footer-ad', '.inline-ad',
            '.native-ad', '.content-ad', '.video-ad', '.display-ad',
            '.square-ad', '.leaderboard-ad', '.skyscraper-ad',
            
            // Termos em outros idiomas
            '[class*="publicidade"]', '[class*="anuncio"]', '[class*="reclame"]',
            '[id*="publicidade"]', '[id*="anuncio"]', '[id*="reclame"]'
        ];
        
        const adDomains = [
            'googlesyndication.com', 'googleadservices.com', 'doubleclick.net',
            'googletagmanager.com', 'google-analytics.com', 'googletagservices.com',
            'facebook.com/tr', 'connect.facebook.net', 'amazon-adsystem.com',
            'adsystem.amazon.com', 'outbrain.com', 'taboola.com',
            'criteo.com', 'adsrvr.org', 'rubiconproject.com',
            'pubmatic.com', 'openx.com', 'adsafeprotected.com'
        ];
        
        function removeAds() {
            // Remove elementos por seletores
            adSelectors.forEach(selector => {
                try {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(el => {
                        el.style.display = 'none !important';
                        el.style.visibility = 'hidden !important';
                        el.style.opacity = '0 !important';
                        el.style.height = '0 !important';
                        el.style.width = '0 !important';
                    });
                } catch(e) {}
            });
            
            // Remove iframes e scripts de anúncios
            const iframes = document.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                if (iframe.src) {
                    const src = iframe.src.toLowerCase();
                    if (adDomains.some(domain => src.includes(domain)) || 
                        src.includes('ad') || src.includes('banner') || src.includes('popup')) {
                        iframe.style.display = 'none !important';
                        iframe.remove();
                    }
                }
            });
            
            // Remove scripts de anúncios
            const scripts = document.querySelectorAll('script');
            scripts.forEach(script => {
                if (script.src) {
                    const src = script.src.toLowerCase();
                    if (adDomains.some(domain => src.includes(domain))) {
                        script.remove();
                    }
                }
            });
            
            // YouTube específico - remove anúncios em vídeos
            const ytAds = document.querySelectorAll('.ytp-ad-skip-button, .ytp-ad-skip-button-modern');
            ytAds.forEach(skipBtn => {
                if (skipBtn.style.display !== 'none') {
                    skipBtn.click();
                }
            });
            
            // Remove overlay de anúncios
            const overlays = document.querySelectorAll('[class*="overlay"]');
            overlays.forEach(overlay => {
                const text = overlay.textContent.toLowerCase();
                if (text.includes('ad') || text.includes('anúncio') || text.includes('publicidade')) {
                    overlay.style.display = 'none !important';
                }
            });
        }
        
        // Executa imediatamente
        removeAds();
        
        // Observa mudanças no DOM
        const observer = new MutationObserver(() => {
            removeAds();
        });
        
        observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['class', 'id', 'src']
        });
        
        // Executa periodicamente para pegar anúncios dinâmicos
        setInterval(removeAds, 2000);
        
        // Bloqueia requisições de anúncios
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            const url = args[0];
            if (typeof url === 'string' && adDomains.some(domain => url.includes(domain))) {
                return Promise.reject(new Error('Blocked by ad blocker'));
            }
            return originalFetch.apply(this, args);
        };
        
        // Bloqueia XMLHttpRequest de anúncios
        const originalXHR = window.XMLHttpRequest.prototype.open;
        window.XMLHttpRequest.prototype.open = function(method, url) {
            if (typeof url === 'string' && adDomains.some(domain => url.includes(domain))) {
                return;
            }
            return originalXHR.apply(this, arguments);
        };
        
        console.log('Ad Blocker ativado');
    })();
    `;
};

webview.addEventListener('did-finish-load', () => {
    webview.executeJavaScript(removeBlankTargets()).catch(err => {
        console.error('Failed to remove blank targets:', err);
    });
});

const btnAdBlocker = header.querySelector('.btn-ad-blocker');

// Event listener para o botão de ad blocker
btnAdBlocker.addEventListener('click', (e) => {
    e.stopPropagation();
    isAdBlockerActive = !isAdBlockerActive;
    btnAdBlocker.classList.toggle('active');
    
    try {
        if (isAdBlockerActive) {
            // Ativa o ad blocker
            webview.executeJavaScript(getAdBlockRules()).catch(err => {
                console.error('Failed to activate ad blocker:', err);
                isAdBlockerActive = false;
                btnAdBlocker.classList.remove('active');
            });
            
            btnAdBlocker.title = 'Disable Ad Blocker';
            btnAdBlocker.style.color = '#4CAF50';
            webview.reload();
        } else {
            // Desativa o ad blocker (recarrega a página)
            webview.reload();
            btnAdBlocker.title = 'Ad Blocker';
            btnAdBlocker.style.color = '';
        }
    } catch (err) {
        console.error('Error toggling ad blocker:', err);
        isAdBlockerActive = false;
        btnAdBlocker.classList.remove('active');
    }
});



    // Event listener para o botão de cópia - CORRIGIDO
    btnCopyElements.addEventListener('click', (e) => {
        e.stopPropagation();
        isCopyModeActive = !isCopyModeActive;
        btnCopyElements.classList.toggle('active');

        try {
            if (isCopyModeActive) {
                // Ativando modo cópia
                webview.executeJavaScript(`
                try {
                    // Limpa qualquer listener anterior
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }

                    // Define o novo handler
                    function copyModeHandler(e) {
    e.preventDefault();
    e.stopPropagation();

    let textToCopy = '';
    if (e.target.href) {
        textToCopy = e.target.href;
    } else if (e.target.src) {
        textToCopy = e.target.src;
    } else {
        const selection = window.getSelection();
        if (selection && selection.toString().trim() !== '') {
            textToCopy = selection.toString();
        } else {
            return;
        }
    }

    // Método moderno com fallback
    if (navigator.clipboard) {
        navigator.clipboard.writeText(textToCopy).then(() => {
            console.log('Copied to clipboard:', textToCopy);
            window.postMessage({ type: 'copyCompleted' }, '*');
        }).catch(err => {
            // Fallback para método antigo se o moderno falhar
            fallbackCopyTextToClipboard(textToCopy);
        });
    } else {
        fallbackCopyTextToClipboard(textToCopy);
    }
}


                    // Armazena o handler globalmente e adiciona o listener
                    window.copyModeHandler = copyModeHandler;
                    document.body.addEventListener('click', copyModeHandler, true);

                    // Muda o cursor para indicar modo cópia
                    document.body.style.cursor = 'copy';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = 'copy';
                    });

                } catch(e) {
                    console.error('Error activating copy mode:', e);
                }
                `).catch(err => {
                    console.error('Failed to activate copy mode:', err);
                    isCopyModeActive = false;
                    btnCopyElements.classList.remove('active');
                });

                //alert('Modo de cópia ativado. Clique em qualquer elemento para copiar seu conteúdo.');

            } else {
                // Desativando modo cópia
                webview.executeJavaScript(`
                try {
                    // Remove o event listener do modo cópia
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }

                    // Restaura o cursor padrão
                    document.body.style.cursor = '';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = '';
                    });

                } catch(e) {
                    console.error('Error deactivating copy mode:', e);
                }
                `).catch(err => {
                    console.error('Failed to deactivate copy mode:', err);
                });

                //alert('Modo de cópia desativado!');
            }

        } catch (err) {
            console.error('Error toggling copy mode:', err);
            isCopyModeActive = false;
            btnCopyElements.classList.remove('active');
        }
    });

    // Listener para quando a cópia for completada
    window.addEventListener('message', (e) => {
        if (e.data.type === 'copyCompleted') {
            isCopyModeActive = false;
            btnCopyElements.classList.remove('active');

            try {
                webview.executeJavaScript(`
                try {
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }
                    document.body.style.cursor = '';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = '';
                    });
                } catch(e) {
                    console.error('Error cleaning up copy mode after completion:', e);
                }
                `).catch(err => {
                    console.error('Failed to clean up copy mode after completion:', err);
                });
            } catch (err) {
                console.error('Error cleaning up copy mode after completion:', err);
            }
        }
    });

    webview.src = savedState ? savedState.url : url;
    webview.setAttribute('allowpopups', '');
    webview.setAttribute('partition', 'persist:trusted');
    
    

    webview.setAttribute('webpreferences', 'clipboard-read=yes, clipboard-write=yes');
    webview.style.background = 'white';

    const applyChromeUserAgentIfNeeded = (currentUrl) => {
        if (currentUrl.includes('web.whatsapp.com')) {
            webview.setAttribute('useragent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36');
        } else {
            webview.removeAttribute('useragent'); // Volta ao user-agent padrão
        }
    };

    // Aplica no carregamento inicial
    applyChromeUserAgentIfNeeded(savedState ? savedState.url : url);

    // Monitora alterações de URL (navegação dentro do webview)
    webview.addEventListener('did-navigate', (e) => {
        applyChromeUserAgentIfNeeded(e.url);
        addToHistory(e.url);

        if (isAdBlockerActive) {
            setTimeout(() => {
                webview.executeJavaScript(getAdBlockRules()).catch(err => {
                    console.error('Failed to reapply ad blocker after navigation:', err);
                });
            }, 1000);
        }

    });

    // Monitora redirecionamentos (como após login)
    webview.addEventListener('did-navigate-in-page', (e) => {
        if (e.isMainFrame) {
            applyChromeUserAgentIfNeeded(e.url);
        }

        if (isAdBlockerActive) {
            setTimeout(() => {
                webview.executeJavaScript(getAdBlockRules()).catch(err => {
                    console.error('Failed to reapply ad blocker after in-page navigation:', err);
                });
            }, 1000);
        }
    });

    content.appendChild(webview);
    tabFrame.appendChild(content);

    addResizers(tabFrame);

    desktop.appendChild(tabFrame);

    const urlInput = header.querySelector('input[type="url"]');

    const suggestionsBox = header.querySelector('.suggestions-box');

    urlInput.addEventListener('input', (e) => {
        const inputText = e.target.value.toLowerCase().trim();
        suggestionsBox.innerHTML = '';

        if (inputText.length === 0) {
            suggestionsBox.style.display = 'none';
            return;
        }

        // Combina histórico e favoritos em uma única lista, sem duplicatas
        const favoriteUrls = favorites.map(fav => fav.url);
        const allSources = [...new Set([...browsingHistory, ...favoriteUrls])];

        const filtered = allSources.filter(item => item.toLowerCase().includes(inputText));

        // Limita a 10 sugestões para não poluir a tela
        const topResults = filtered.slice(0, 10);

        if (topResults.length > 0) {
            topResults.forEach(suggestionUrl => {
                const item = document.createElement('div');
                item.classList.add('suggestion-item');
                item.textContent = suggestionUrl;
                item.title = suggestionUrl; // Mostra URL completa no hover

                // Evento de clique em uma sugestão
                item.addEventListener('mousedown', (event) => {
                    event.preventDefault(); // Previne que o input perca o foco antes do clique
                    urlInput.value = suggestionUrl;
                    webview.src = suggestionUrl;
                    suggestionsBox.style.display = 'none';
                    saveState();
                });

                suggestionsBox.appendChild(item);
            });
            suggestionsBox.style.display = 'block';
        } else {
            suggestionsBox.style.display = 'none';
        }
    });

    // Esconde a caixa de sugestões quando o input perde o foco
    urlInput.addEventListener('blur', () => {
        // Usamos um pequeno timeout para permitir que o clique no item de sugestão seja registrado
        setTimeout(() => {
            suggestionsBox.style.display = 'none';
        }, 150);
    });

    // Mostra a caixa de sugestões quando o input ganha foco e já tem texto
    urlInput.addEventListener('focus', () => {
        if (urlInput.value.trim().length > 0) {
            // Dispara o evento 'input' para re-filtrar e mostrar as sugestões
            urlInput.dispatchEvent(new Event('input'));
        }
    });
    // **FIM DA LÓGICA DE SUGESTÕES**

    const btnMaximize = header.querySelector('.btn-maximize');
    const btnClose = header.querySelector('.btn-close');
    const btnMoveToBoard = header.querySelector('.btn-move-to-board');
    const moveToBoardMenu = header.querySelector('.move-to-board-menu');
    const goBackBtn = header.querySelector('.btn-back');
    const goForwardBtn = header.querySelector('.btn-forward');
    const refreshBtn = header.querySelector('.btn-refresh');
    const pinBtn = header.querySelector('.btn-pin');
    const btnEditHtml = header.querySelector('.btn-edit-html');

    btnEditHtml.addEventListener('click', async (e) => {
        e.stopPropagation();

        try {
            // Obtém o HTML da página atual
            const html = await webview.executeJavaScript(`
            document.documentElement.outerHTML
            `);

            // Cria um novo campo de texto com o HTML
            const textFieldId = createTextField({
                content: html,
                title: `HTML Export: ${webview.getTitle() || 'Untitled'}`,
                                                position: {
                                                    top: '100px',
                                                    left: '100px',
                                                    zIndex: 200 + textFieldIdCounter
                                                },
                                                size: {
                                                    width: '800px',
                                                    height: '600px'
                                                }
            }, currentBoardId);

            // Adiciona um listener para atualizar o webview quando o texto for alterado
            const textField = boards[currentBoardId].textFields.find(t => t.id === textFieldId);
            const textarea = textField.textarea;

            textarea.addEventListener('input', () => {
                try {
                    // Atualiza o webview com o novo HTML
                    webview.executeJavaScript(`
                    document.open();
                    document.write(\`${textarea.value.replace(/`/g, '\\`')}\`);
                    document.close();
                    `);
                } catch (error) {
                    console.error('Error updating webview:', error);
                }
            });

        } catch (error) {
            console.error('Error exporting HTML:', error);
            showMessage('Failed to export HTML. The page may have restrictions.');
        }
    });

    function updatePinButton() {
        if (isFavorite(webview.src)) {
            pinBtn.classList.add('pinned');
            pinBtn.title = 'Unpin from favorites';
        } else {
            pinBtn.classList.remove('pinned');
            pinBtn.title = 'Pin to favorites';
        }
    }

    pinBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const url = webview.src;

        if (isFavorite(url)) {
            removeFavorite(url);
        } else {
            addFavorite(url, document.title || new URL(url).hostname);
        }

        updatePinButton();
    });

    webview.addEventListener('did-navigate', (e) => {
        urlInput.value = e.url;
        updatePinButton();
    });

    webview.addEventListener('page-title-updated', (e) => {
        if (isFavorite(webview.src)) {
            const favIndex = favorites.findIndex(fav => fav.url === webview.src);
            if (favIndex !== -1) {
                favorites[favIndex].title = e.title;
                saveFavorites();
                updateFavoritesGrid();
            }
        }
    });

    function updateMoveToBoardMenu() {
        moveToBoardMenu.innerHTML = '';

        Object.keys(boards).forEach(targetBoardId => {
            if (targetBoardId !== boardId) {
                const button = document.createElement('button');
                button.textContent = boards[targetBoardId].name;
                button.addEventListener('click', () => {
                    moveItemToBoard('tab', id, targetBoardId);
                });
                moveToBoardMenu.appendChild(button);
            }
        });
    }

    btnMoveToBoard.addEventListener('click', (e) => {
        e.stopPropagation();
        updateMoveToBoardMenu();
        moveToBoardMenu.style.display = moveToBoardMenu.style.display === 'block' ? 'none' : 'block';
    });

    document.addEventListener('click', (e) => {
        if (!header.contains(e.target)) {
            moveToBoardMenu.style.display = 'none';
        }
    });

    makeDraggable(tabFrame, header);

    // Event listener principal do tabFrame - CORRIGIDO
    tabFrame.addEventListener('click', (e) => {
        // Verifica se o clique foi no botão de cópia - se sim, não desativa
        if (e.target.closest('.btn-copy-elements')) {
            return;
        }

        // Se o modo cópia estiver ativo e o clique não foi no botão, desativa
        if (isCopyModeActive) {
            isCopyModeActive = false;
            btnCopyElements.classList.remove('active');

            try {
                webview.executeJavaScript(`
                try {
                    if (window.copyModeHandler) {
                        document.body.removeEventListener('click', window.copyModeHandler, true);
                        delete window.copyModeHandler;
                    }
                    document.body.style.cursor = '';
                    const interactiveElements = document.querySelectorAll('a, img, button, input, [contenteditable]');
                    interactiveElements.forEach(el => {
                        el.style.cursor = '';
                    });
                } catch(e) {
                    console.error('Error disabling copy mode from tab click:', e);
                }
                `).catch(err => {
                    console.error('Failed to disable copy mode from tab click:', err);
                });
            } catch (err) {
                console.error('Error disabling copy mode from tab click:', err);
            }
            return;
        }

        // Resto da lógica original do clique no tab...
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' || e.target.classList.contains('resizer')) return;

        removeAllFocus();
        tabFrame.classList.add('focused');
        urlInput.style.display = 'block';
        urlInput.value = webview.src || url;
        urlInput.focus();
        urlInput.select();

        boards[boardId].activeTabId = id;
        boards[boardId].activeTextFieldId = null;
        boards[boardId].activeListId = null;
        activeTabId = id;
        activeTextFieldId = null;
        activeListId = null;

        saveState();
    });

    urlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            let newUrl = urlInput.value.trim();
            if (newUrl && !newUrl.includes('.') && !newUrl.startsWith('http')) {
                switch (defaultSearchEngine) {
                    case 'google':
                        newUrl = `https://www.google.com/search?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'duckduckgo':
                        newUrl = `https://duckduckgo.com/?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'bing':
                        newUrl = `https://www.bing.com/search?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'perplexity':
                        newUrl = `https://www.perplexity.ai/?q=${encodeURIComponent(newUrl)}`;
                        break;
                    case 'chatgpt':
                        newUrl = `https://chatgpt.com/?q=${encodeURIComponent(newUrl)}`;
                        break;
                }
            } else if (!newUrl.startsWith('http')) {
                newUrl = 'https://' + newUrl;
            }

            if (newUrl) {
                webview.src = newUrl;
                tabFrame.classList.remove('focused');
                saveState();
            }
        }
    });

    urlInput.addEventListener('blur', () => {
        setTimeout(() => {
            tabFrame.classList.remove('focused');
        }, 100);
    });

    btnClose.addEventListener('click', (e) => {
        e.stopPropagation();
        
        // Animação de explosão
        const tabRect = tabFrame.getBoundingClientRect();
        const centerX = tabRect.left + tabRect.width / 2;
        const centerY = tabRect.top + tabRect.height / 2;
        
        // Aplica animação de explosão no frame
        tabFrame.style.transformOrigin = 'center';
        tabFrame.style.animation = 'explode 0.3s ease-out forwards';
        
        // Cria partículas de fumaça
        for (let i = 0; i < 15; i++) {
            createSmokeParticle(centerX, centerY);
        }
        
        // Remove o frame após a animação
        setTimeout(() => {
            tabFrame.remove();
            
            // Remove a aba da lista de abas do board
            const board = boards[boardId];
            board.tabs = board.tabs.filter(tab => tab.id !== id);
            
            if (activeTabId === id) {
            activeTabId = null;
            board.activeTabId = null;
            }
            
            saveState();
        }, 300);
    });

    refreshBtn.addEventListener('click', (e) => {
        webview.reload();
    });

    goForwardBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        try {
            if(webview.canGoForward()){
                webview.goForward();
            }
        } catch(error) {}
    });

    goBackBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        try {
            if(webview.canGoBack()){
                webview.goBack();
            }
        } catch(error) {}
    });

    btnMaximize.addEventListener('click', (e) => {
        e.stopPropagation();
        const tab = boards[boardId].tabs.find(t => t.id === id);
        if (tab.tabFrame.classList.contains('maximized-tab')) {
            tab.tabFrame.classList.remove('maximized-tab');
            tab.tabFrame.style.top = savedState?.position?.top || '50px';
            tab.tabFrame.style.left = savedState?.position?.left || '50px';
            tab.tabFrame.style.width = '600px';
            tab.tabFrame.style.height = '400px';
            tab.tabFrame.style.borderRadius = '8px';
            tab.tabFrame.style.boxShadow = '0 0 15px rgba(0,0,0,0.7)';
            tab.tabFrame.style.zIndex = savedState?.position?.zIndex || (100 + id);
        } else {
            maximizeTab(id);
        }
        saveState();
    });

    tabFrame.addEventListener('wheel', e => {
        if (e.ctrlKey) {
            e.preventDefault();
            let zoom = webview.getZoomFactor();
            zoom += e.deltaY * -0.0015;
            zoom = Math.min(Math.max(zoom, 0.25), 3);
            webview.setZoomFactor(zoom);
        }
    });

    boards[boardId].tabs.push({ id, tabFrame, webview, minimized: false, url: savedState ? savedState.url : url, anonima: false });

    if (savedState?.maximized) {
        maximizeTab(id);
    }

    if (boardId !== currentBoardId) {
        tabFrame.style.display = 'none';
    }

    updatePinButton();

    return id;
}

function createSmokeParticle(x, y) {
  const particle = document.createElement('div');
  particle.classList.add('smoke-particle');
  
  // Tamanho aleatório
  const size = Math.random() * 15 + 5;
  particle.style.width = `${size}px`;
  particle.style.height = `${size}px`;
  
  // Posição inicial
  particle.style.left = `${x}px`;
  particle.style.top = `${y}px`;
  
  // Direção aleatória
  const angle = Math.random() * Math.PI * 2;
  const distance = Math.random() * 100 + 50;
  const tx = Math.cos(angle) * distance;
  const ty = Math.sin(angle) * distance;
  
  particle.style.setProperty('--tx', `${tx}px`);
  particle.style.setProperty('--ty', `${ty}px`);
  
  // Cor aleatória (tons de cinza)
  const grayValue = Math.floor(Math.random() * 100 + 100);
  particle.style.backgroundColor = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
  
  document.body.appendChild(particle);
  
  // Remove a partícula após a animação
  setTimeout(() => {
    particle.remove();
  }, 1500);
}

function createTextField(savedState = null, targetBoardId = null, initialText = null) {
    const boardId = targetBoardId || currentBoardId;
    if (!boardId || !boards[boardId]) return;

    // Determina se é uma chamada normal ou com configuração completa
    const isConfigObject = savedState && typeof savedState === 'object' && !savedState.id;

    const id = isConfigObject ? ++textFieldIdCounter : (savedState?.id || ++textFieldIdCounter);
    if (!isConfigObject) textFieldIdCounter = Math.max(textFieldIdCounter, id);

    const tabFrame = document.createElement('div');
    tabFrame.classList.add('textfield-frame');

    if (savedState) {
        if (isConfigObject) {
            // Chamada com objeto de configuração completa (do Edit as HTML)
            tabFrame.style.top = savedState.position?.top || '120px';
            tabFrame.style.left = savedState.position?.left || (80 + boards[boardId].textFields.length * 30) + 'px';
            tabFrame.style.zIndex = savedState.position?.zIndex || (200 + id);
            tabFrame.style.width = '600px';
            tabFrame.style.height = '400px';
        } else {
            // Chamada normal com savedState
            tabFrame.style.top = savedState.position?.top || '120px';
            tabFrame.style.left = savedState.position?.left || (80 + boards[boardId].textFields.length * 30) + 'px';
            tabFrame.style.zIndex = savedState.position?.zIndex || (200 + id);
            tabFrame.style.width = '600px';
            tabFrame.style.height = '400px';
            if (savedState.maximized) {
                //tabFrame.classList.add('maximized-textfield');
            }
        }
    } else {
        // Chamada sem parâmetros
        tabFrame.style.top = '120px';
        tabFrame.style.left = (80 + boards[boardId].textFields.length * 30) + 'px';
        tabFrame.style.zIndex = 200 + id;
        tabFrame.style.width = '600px';
        tabFrame.style.height = '400px';
    }

    tabFrame.dataset.id = id;

    const header = document.createElement('div');
    header.classList.add('textfield-header');
    header.innerHTML = `
    <input type='text' class="title-section" value='${
        isConfigObject ?
        (savedState.title || `Campo de Texto #${id}`) :
        (savedState?.title || `Campo de Texto #${id}`)
    }'>
    <div class="controls">
    <div class="move-to-board-container">
    <button class="btn-move-to-board" title="Move to another board">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move3d-icon lucide-move-3d"><path d="M5 3v16h16"/><path d="m5 19 6-6"/><path d="m2 6 3-3 3 3"/><path d="m18 16 3 3-3 3"/></svg>
    </button>
    <div class="move-to-board-menu"></div>
    </div>
    <button title="Change Size" class="btn-maximize">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2-icon lucide-maximize-2"><path d="M15 3h6v6"/><path d="m21 3-7 7"/><path d="m3 21 7-7"/><path d="M9 21H3v-6"/></svg>
    </button>
    <button title="Close" class="btn-close">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
    </button>
    </div>
    `;
    tabFrame.appendChild(header);

    const content = document.createElement('div');
    content.classList.add('textfield-content');
    const textarea = document.createElement('textarea');
    textarea.placeholder = 'Digite seu texto aqui...';

    // Definir o conteúdo do textarea
    let textContent = '';
    
    if (initialText !== null) {
        // Se foi passado um texto inicial, usar ele
        textContent = initialText;
    } else if (savedState) {
        // Se não há texto inicial mas há savedState, usar o conteúdo salvo
        if (isConfigObject) {
            textContent = savedState.content || '';
        } else {
            textContent = savedState.content || '';
        }
    }
    
    textarea.value = textContent;
    
    content.appendChild(textarea);
    tabFrame.appendChild(content);

    addResizers(tabFrame);

    desktop.appendChild(tabFrame);

    const titleInput = header.querySelector('.title-section');
    const btnMaximize = header.querySelector('.btn-maximize');
    const btnClose = header.querySelector('.btn-close');
    const btnMoveToBoard = header.querySelector('.btn-move-to-board');
    const moveToBoardMenu = header.querySelector('.move-to-board-menu');

    function updateMoveToBoardMenu() {
        moveToBoardMenu.innerHTML = '';

        Object.keys(boards).forEach(targetBoardId => {
            if (targetBoardId !== boardId) {
                const button = document.createElement('button');
                button.textContent = boards[targetBoardId].name;
                button.addEventListener('click', () => {
                    moveItemToBoard('textField', id, targetBoardId);
                });
                moveToBoardMenu.appendChild(button);
            }
        });
    }

    btnMoveToBoard.addEventListener('click', (e) => {
        e.stopPropagation();
        updateMoveToBoardMenu();
        moveToBoardMenu.style.display = moveToBoardMenu.style.display === 'block' ? 'none' : 'block';
    });

    document.addEventListener('click', (e) => {
        if (!header.contains(e.target)) {
            moveToBoardMenu.style.display = 'none';
        }
    });

    makeDraggable(tabFrame, header);

    titleInput.addEventListener('change', () => {
        saveState();
    });

    textarea.addEventListener('input', () => {
        saveState();
    });

    tabFrame.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON' || e.target.classList.contains('resizer')) return;

        removeAllFocus();

        tabFrame.classList.add('focused');

        boards[boardId].activeTabId = null;
        boards[boardId].activeTextFieldId = id;
        boards[boardId].activeListId = null;
        activeTabId = null;
        activeTextFieldId = id;
        activeListId = null;

        saveState();
    });

    btnClose.addEventListener('click', (e) => {
        e.stopPropagation();
        
        // Animação de explosão
        const tabRect = tabFrame.getBoundingClientRect();
        const centerX = tabRect.left + tabRect.width / 2;
        const centerY = tabRect.top + tabRect.height / 2;
        
        // Aplica animação de explosão no frame
        tabFrame.style.transformOrigin = 'center';
        tabFrame.style.animation = 'explode 0.3s ease-out forwards';
        
        // Cria partículas de fumaça
        for (let i = 0; i < 15; i++) {
            createSmokeParticle(centerX, centerY);
        }
        
        // Remove o frame após a animação
        setTimeout(() => {
            closeTextField(id);
            saveState();
        }, 300);
    });

    btnMaximize.addEventListener('click', (e) => {
        e.stopPropagation();
        const textField = boards[boardId].textFields.find(t => t.id === id);
        if (textField.textFieldFrame.classList.contains('maximized-textfield')) {
            textField.textFieldFrame.classList.remove('maximized-textfield');
            textField.textFieldFrame.style.top = savedState?.position?.top || '80px';
            textField.textFieldFrame.style.left = savedState?.position?.left || (80 + id * 30) + 'px';
            textField.textFieldFrame.style.width = '600px';
            textField.textFieldFrame.style.height = '400px';
            textField.textFieldFrame.style.borderRadius = '8px';
            textField.textFieldFrame.style.boxShadow = '0 0 15px rgba(0,0,0,0.7)';
            textField.textFieldFrame.style.zIndex = savedState?.position?.zIndex || (200 + id);
        } else {
            maximizeTextField(id);
        }
        saveState();
    });

    boards[boardId].textFields.push({ id, textFieldFrame: tabFrame, textarea, minimized: false });

    if (savedState?.maximized && !isConfigObject) {
        maximizeTextField(id);
    }

    if (boardId !== currentBoardId) {
        tabFrame.style.display = 'none';
    }

    return id;
}

function createList(savedState = null, targetBoardId = null) {
    const boardId = targetBoardId || currentBoardId;
    if (!boardId || !boards[boardId]) return;

    const id = savedState ? savedState.id : ++listIdCounter;
    if (!savedState) listIdCounter = Math.max(listIdCounter, id);

    const listFrame = document.createElement('div');
    listFrame.classList.add('list-frame');

    if (savedState) {
        listFrame.style.top = savedState.position.top || '110px';
        listFrame.style.left = savedState.position.left || (110 + id * 30) + 'px';
        listFrame.style.zIndex = savedState.position.zIndex || (300 + id);
        listFrame.style.width = '400px';
        listFrame.style.height = '300px';
        if (savedState.maximized) {
            //listFrame.classList.add('maximized-list');
        }
    } else {
        listFrame.style.top = '110px';
        listFrame.style.left = (110 + id * 30) + 'px';
        listFrame.style.zIndex = 300 + id;
        listFrame.style.width = '400px';
        listFrame.style.height = '300px';
    }

    listFrame.dataset.id = id;

    const header = document.createElement('div');
    header.classList.add('list-header');
    header.innerHTML = `
    <input type='text' class="title-section" value='${savedState?.title || `Lista #${id}`}'>
    <div class="controls">
    <div class="move-to-board-container">
    <button class="btn-move-to-board" title="Move to another board">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move3d-icon lucide-move-3d"><path d="M5 3v16h16"/><path d="m5 19 6-6"/><path d="m2 6 3-3 3 3"/><path d="m18 16 3 3-3 3"/></svg>
    </button>
    <div class="move-to-board-menu"></div>
    </div>
    <button title="Change size" class="btn-maximize"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize2-icon lucide-maximize-2"><path d="M15 3h6v6"/><path d="m21 3-7 7"/><path d="m3 21 7-7"/><path d="M9 21H3v-6"/></svg></button>
    <button title="Close" class="btn-close">
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
    </button>
    </div>
    `;
    listFrame.appendChild(header);

    const content = document.createElement('div');
    content.classList.add('list-content');
    listFrame.appendChild(content);

    if (savedState?.items) {
        savedState.items.forEach(item => {
            addListItem(content, item.checked, item.text);
        });
    } else {
        addListItem(content, false, 'Item 1');
    }

    const addButton = document.createElement('button');
    addButton.classList.add('add-checkbox-btn');
    addButton.textContent = 'New Checkbox';
    addButton.addEventListener('click', () => {
        addListItem(content, false, 'New item');
        saveState();
    });
    content.appendChild(addButton);

    addResizers(listFrame);

    desktop.appendChild(listFrame);

    const titleInput = header.querySelector('.title-section');
    const btnMaximize = header.querySelector('.btn-maximize');
    const btnClose = header.querySelector('.btn-close');
    const btnMoveToBoard = header.querySelector('.btn-move-to-board');
    const moveToBoardMenu = header.querySelector('.move-to-board-menu');

    function updateMoveToBoardMenu() {
        moveToBoardMenu.innerHTML = '';

        Object.keys(boards).forEach(targetBoardId => {
            if (targetBoardId !== boardId) {
                const button = document.createElement('button');
                button.textContent = boards[targetBoardId].name;
                button.addEventListener('click', () => {
                    moveItemToBoard('list', id, targetBoardId);
                });
                moveToBoardMenu.appendChild(button);
            }
        });
    }

    btnMoveToBoard.addEventListener('click', (e) => {
        e.stopPropagation();
        updateMoveToBoardMenu();
        moveToBoardMenu.style.display = moveToBoardMenu.style.display === 'block' ? 'none' : 'block';
    });

    document.addEventListener('click', (e) => {
        if (!header.contains(e.target)) {
            moveToBoardMenu.style.display = 'none';
        }
    });

    makeDraggable(listFrame, header);

    titleInput.addEventListener('change', () => {
        saveState();
    });

    function setupListItemListeners(item) {
        const checkbox = item.querySelector('input[type="checkbox"]');
        const textInput = item.querySelector('input[type="text"]');
        const deleteBtn = item.querySelector('.delete-item');

        checkbox.addEventListener('change', () => {
            saveState();
        });

        textInput.addEventListener('input', () => {
            saveState();
        });

        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            item.remove();
            saveState();
        });
    }

    content.querySelectorAll('.list-item').forEach(item => {
        setupListItemListeners(item);
    });

    listFrame.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON' || e.target.classList.contains('resizer')) return;

        removeAllFocus();

        listFrame.classList.add('focused');

        boards[boardId].activeTabId = null;
        boards[boardId].activeTextFieldId = null;
        boards[boardId].activeListId = id;
        activeTabId = null;
        activeTextFieldId = null;
        activeListId = id;

        saveState();
    });

    btnClose.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // Animação de explosão
    const listRect = listFrame.getBoundingClientRect();
    const centerX = listRect.left + listRect.width / 2;
    const centerY = listRect.top + listRect.height / 2;
    
    // Aplica animação de explosão no frame
    listFrame.style.transformOrigin = 'center';
    listFrame.style.animation = 'explode 0.3s ease-out forwards';
    
    // Cria partículas de fumaça
    for (let i = 0; i < 15; i++) {
        createSmokeParticle(centerX, centerY);
    }
    
    // Remove o frame após a animação
    setTimeout(() => {
        closeList(id);
        saveState();
    }, 300);
});

    btnMaximize.addEventListener('click', (e) => {
        e.stopPropagation();
        const list = boards[boardId].lists.find(l => l.id === id);
        if (list.listFrame.classList.contains('maximized-list')) {
            list.listFrame.classList.remove('maximized-list');
            list.listFrame.style.top = savedState?.position?.top || '110px';
            list.listFrame.style.left = savedState?.position?.left || (110 + id * 30) + 'px';
            list.listFrame.style.width = '400px';
            list.listFrame.style.height = '300px';
            list.listFrame.style.borderRadius = '8px';
            list.listFrame.style.boxShadow = '0 0 15px rgba(0,0,0,0.7)';
            list.listFrame.style.zIndex = savedState?.position?.zIndex || (300 + id);
        } else {
            maximizeList(id);
        }
        saveState();
    });

    boards[boardId].lists.push({
        id,
        listFrame,
        listContent: content,
        minimized: false
    });

    if (savedState?.maximized) {
        maximizeList(id);
    }

    if (boardId !== currentBoardId) {
        listFrame.style.display = 'none';
    }

    return id;
}

function moveItemToBoard(type, itemId, targetBoardId) {
    if (!currentBoardId || !boards[currentBoardId] || !boards[targetBoardId]) return;

    const sourceBoard = boards[currentBoardId];
    const targetBoard = boards[targetBoardId];

    let item;
    let savedState;

    if (type === 'tab') {
        item = sourceBoard.tabs.find(t => t.id === itemId);
        if (!item) return;

        savedState = {
            id: item.id,
            url: item.webview.src,
            position: {
                top: item.tabFrame.style.top,
                left: item.tabFrame.style.left,
                zIndex: item.tabFrame.style.zIndex
            },
            size: {
                width: item.tabFrame.style.width,
                height: item.tabFrame.style.height
            },
            maximized: item.tabFrame.classList.contains('maximized-tab')
        };

        sourceBoard.tabs = sourceBoard.tabs.filter(t => t.id !== itemId);
        if (sourceBoard.activeTabId === itemId) {
            sourceBoard.activeTabId = null;
        }

        createTab(savedState.url, savedState, targetBoardId);

    } else if (type === 'textField') {
        item = sourceBoard.textFields.find(t => t.id === itemId);
        if (!item) return;

        savedState = {
            id: item.id,
            content: item.textarea.value,
            title: item.textFieldFrame.querySelector('.title-section').value,
            position: {
                top: item.textFieldFrame.style.top,
                left: item.textFieldFrame.style.left,
                zIndex: item.textFieldFrame.style.zIndex
            },
            size: {
                width: item.textFieldFrame.style.width,
                height: item.textFieldFrame.style.height
            },
            maximized: item.textFieldFrame.classList.contains('maximized-textfield')
        };

        sourceBoard.textFields = sourceBoard.textFields.filter(t => t.id !== itemId);
        if (sourceBoard.activeTextFieldId === itemId) {
            sourceBoard.activeTextFieldId = null;
        }

        createTextField(savedState, targetBoardId);

    } else if (type === 'list') {
        item = sourceBoard.lists.find(l => l.id === itemId);
        if (!item) return;

        savedState = {
            id: item.id,
            title: item.listFrame.querySelector('.title-section').value,
            items: Array.from(item.listContent.querySelectorAll('.list-item')).map(item => ({
                checked: item.querySelector('input[type="checkbox"]').checked,
                                                                                            text: item.querySelector('input[type="text"]').value
            })),
            position: {
                top: item.listFrame.style.top,
                left: item.listFrame.style.left,
                zIndex: item.listFrame.style.zIndex
            },
            size: {
                width: item.listFrame.style.width,
                height: item.listFrame.style.height
            },
            maximized: item.listFrame.classList.contains('maximized-list')
        };

        sourceBoard.lists = sourceBoard.lists.filter(l => l.id !== itemId);
        if (sourceBoard.activeListId === itemId) {
            sourceBoard.activeListId = null;
        }

        createList(savedState, targetBoardId);
    }

    if (item) {
        if (type === 'tab') {
            item.tabFrame.remove();
        } else if (type === 'textField') {
            item.textFieldFrame.remove();
        } else if (type === 'list') {
            item.listFrame.remove();
        }
    }

    saveState();
}

function addListItem(container, checked = false, text = '') {
    const item = document.createElement('div');
    item.classList.add('list-item');
    item.innerHTML = `
    <input type="checkbox" ${checked ? 'checked' : ''}>
    <input type="text" value="${text}">
    <button class="delete-item" title="Remove item">×</button>
    `;
    container.insertBefore(item, container.querySelector('.add-checkbox-btn'));

    const checkbox = item.querySelector('input[type="checkbox"]');
    const textInput = item.querySelector('input[type="text"]');
    const deleteBtn = item.querySelector('.delete-item');

    checkbox.addEventListener('change', () => {
        saveState();
    });

    textInput.addEventListener('input', () => {
        saveState();
    });

    deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        item.remove();
        saveState();
    });
}

function addResizers(element) {
    const resizers = ['top', 'right', 'bottom', 'left', 'top-left', 'top-right', 'bottom-left', 'bottom-right'];

    resizers.forEach(direction => {
        const resizer = document.createElement('div');
        resizer.classList.add('resizer', `resizer-${direction}`);
        element.appendChild(resizer);

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = parseInt(document.defaultView.getComputedStyle(element).width, 10);
            const startHeight = parseInt(document.defaultView.getComputedStyle(element).height, 10);
            const startLeft = parseInt(document.defaultView.getComputedStyle(element).left, 10);
            const startTop = parseInt(document.defaultView.getComputedStyle(element).top, 10);

            function doResize(e) {
                if (direction.includes('right')) {
                    const width = startWidth + (e.clientX - startX);
                    if (width > 300) element.style.width = width + 'px';
                }
                if (direction.includes('bottom')) {
                    const height = startHeight + (e.clientY - startY);
                    if (height > 200) element.style.height = height + 'px';
                }
                if (direction.includes('left')) {
                    const width = startWidth - (e.clientX - startX);
                    if (width > 300) {
                        element.style.width = width + 'px';
                        element.style.left = (startLeft + (e.clientX - startX)) + 'px';
                    }
                }
                if (direction.includes('top')) {
                    const height = startHeight - (e.clientY - startY);
                    if (height > 200) {
                        element.style.height = height + 'px';
                        element.style.top = (startTop + (e.clientY - startY)) + 'px';
                    }
                }
            }

            function stopResize() {
                window.removeEventListener('mousemove', doResize);
                window.removeEventListener('mouseup', stopResize);
                saveState();
            }

            window.addEventListener('mousemove', doResize);
            window.addEventListener('mouseup', stopResize);
        });
    });
}

function removeAllFocus() {
    if (!currentBoardId) return;

    const board = boards[currentBoardId];
    board.tabs.forEach(tab => {
        tab.tabFrame.classList.remove('focused');
        const input = tab.tabFrame.querySelector('input[type="url"]');
    });
    board.textFields.forEach(textField => {
        textField.textFieldFrame.classList.remove('focused');
    });
    board.lists.forEach(list => {
        list.listFrame.classList.remove('focused');
    });

    board.activeTabId = null;
    board.activeTextFieldId = null;
    board.activeListId = null;
    activeTabId = null;
    activeTextFieldId = null;
    activeListId = null;
}

function closeTab(id) {
    if (!currentBoardId) return;

    const board = boards[currentBoardId];
    const tab = board.tabs.find(t => t.id === id);
    if (!tab) return;

    tab.tabFrame.remove();
    board.tabs = board.tabs.filter(t => t.id !== id);

    if (activeTabId === id) {
        activeTabId = null;
        board.activeTabId = null;
    }

    saveState();
}

function closeTextField(id) {
    if (!currentBoardId) return;

    const board = boards[currentBoardId];
    const textField = board.textFields.find(t => t.id === id);
    if (!textField) return;

    textField.textFieldFrame.remove();
    board.textFields = board.textFields.filter(t => t.id !== id);

    if (activeTextFieldId === id) {
        activeTextFieldId = null;
        board.activeTextFieldId = null;
    }

    saveState();
}

function closeList(id) {
    if (!currentBoardId) return;

    const board = boards[currentBoardId];
    const list = board.lists.find(l => l.id === id);
    if (!list) return;

    list.listFrame.remove();
    board.lists = board.lists.filter(l => l.id !== id);

    if (activeListId === id) {
        activeListId = null;
        board.activeListId = null;
    }

    saveState();
}

function maximizeTab(id) {
    if (!currentBoardId) return;

    const board = boards[currentBoardId];
    board.tabs.forEach(t => {
        if (t.id === id) {
            t.tabFrame.classList.add('maximized-tab');
            t.tabFrame.style.top = '0';
            t.tabFrame.style.left = '0';
            t.tabFrame.style.width = '100%';
            t.tabFrame.style.height = '100%';
            t.tabFrame.style.borderRadius = '0';
            t.tabFrame.style.boxShadow = 'none';
            t.tabFrame.style.zIndex = '9999';
            removeElementsByClass("chat-input-container");
            chatInputDraggable = null;
            
        } else {
            t.tabFrame.classList.remove('maximized-tab');
        }
    });

    saveState();
}

function maximizeTextField(id) {
    if (!currentBoardId) return;

    const board = boards[currentBoardId];
    board.textFields.forEach(t => {
        if (t.id === id) {
            t.textFieldFrame.classList.add('maximized-textfield');
            t.textFieldFrame.style.top = '0';
            t.textFieldFrame.style.left = '0';
            t.textFieldFrame.style.width = '100%';
            t.textFieldFrame.style.height = '100%';
            t.textFieldFrame.style.borderRadius = '0';
            t.textFieldFrame.style.boxShadow = 'none';
            t.textFieldFrame.style.zIndex = '9999';
            removeElementsByClass("chat-input-container");
            chatInputDraggable = null;
        } else {
            t.textFieldFrame.classList.remove('maximized-textfield');
        }
    });

    saveState();
}

function maximizeList(id) {
    if (!currentBoardId) return;

    const board = boards[currentBoardId];
    board.lists.forEach(l => {
        if (l.id === id) {
            l.listFrame.classList.add('maximized-list');
            l.listFrame.style.top = '0';
            l.listFrame.style.left = '0';
            l.listFrame.style.width = '100%';
            l.listFrame.style.height = '100%';
            l.listFrame.style.borderRadius = '0';
            l.listFrame.style.boxShadow = 'none';
            l.listFrame.style.zIndex = '9999';
            removeElementsByClass("chat-input-container");
            chatInputDraggable = null;
        } else {
            l.listFrame.classList.remove('maximized-list');
        }
    });

    saveState();
}



function makeDraggable(element, handle) {
    let isDragging = false;
    let startX, startY, origX, origY;
    let originalZIndex = element.style.zIndex;

    handle.addEventListener('mousedown', e => {
        // Verifica se é um Text Field ou List e se o modo mover está inativo
        const isTextFieldOrList = element.classList.contains('textfield-frame') ||
        element.classList.contains('list-frame') || element.classList.contains('tab-frame');

        if (isTextFieldOrList && !isMoveModeActive) {
            return; // Impede o arrasto se for Text Field/List e o modo mover estiver desligado
        }

        // Permite arrasto apenas no cabeçalho (exceto em inputs/botões)
        if (e.target.tagName === 'INPUT' ||
            e.target.tagName === 'BUTTON' ||
            e.target.classList.contains('resizer')) {
            return;
            }

            isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        const rect = element.getBoundingClientRect();
        origX = parseInt(element.style.left) || rect.left;
        origY = parseInt(element.style.top) || rect.top;
        handle.style.cursor = 'grabbing';
        element.classList.add('dragging');
        element.style.zIndex = '10000';
        e.preventDefault();
    });

    function stopDragging() {
        if (isDragging) {
            isDragging = false;
            handle.style.cursor = isMoveModeActive ? 'move' : 'grab';
            element.classList.remove('dragging');
            element.style.zIndex = originalZIndex;
            document.body.classList.remove('item-dragging');
            saveState();
        }
    }

    window.addEventListener('mouseup', stopDragging);
    window.addEventListener('blur', stopDragging);

    window.addEventListener('mousemove', e => {
        if (!isDragging) return;

        let newX = origX + (e.clientX - startX);
        let newY = origY + (e.clientY - startY);

        newX = Math.max(0, Math.min(newX, desktop.offsetWidth - element.offsetWidth));
        newY = Math.max(0, Math.min(newY, desktop.offsetHeight - element.offsetHeight));

        element.style.left = newX + 'px';
        element.style.top = newY + 'px';
    });
}
/*
 d es*ktop.addEventListener('click', e => {
 if (e.target === desktop) {
     removeAllFocus();
     if (isMoveModeActive) {
         btnMoveMode.click();
         }
         }
         });*/

window.addEventListener('beforeunload', () => {
    saveState();
});

// Inicializa o canvas de desenho quando o DOM estiver pronto
document.addEventListener('DOMContentLoaded', () => {
    applyThemeColor();
    initDrawingCanvas();
    loadState();
    initiateButtons();
    if (selectedIcon) {
        updateAppIcon(selectedIcon);
    }
});

window.addEventListener('resize', () => {
    resizeCanvas();
});

// Adiciona listener para a tecla ESC
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        // Encontra todos os elementos sendo arrastados
        const draggingElements = document.querySelectorAll('.dragging');

        if (draggingElements.length > 0) {
            // Para cada elemento sendo arrastado, dispara o evento de mouseup
            draggingElements.forEach(element => {
                const event = new MouseEvent('mouseup');
                window.dispatchEvent(event);
            });

            // Sai do modo mover se estiver ativo
            if (isMoveModeActive) {
                btnMoveMode.click();
            }
        }
    }
    else if(e.ctrlKey && e.key === 'b'){
        e.preventDefault();
        createBoard(`Board ${boardIdCounter + 1}`);
    }
    else if(e.ctrlKey && e.key === 'w'){
        e.preventDefault();
        createTab();
    }
    else if(e.ctrlKey && e.key === 't'){
        e.preventDefault();
        createTextField();
    }
    else if(e.ctrlKey && e.key === 'l'){
        e.preventDefault();
        createList();
    }
    else if(e.ctrlKey && e.key === 'r'){
        e.preventDefault();
        showRenameModal();
    }
    else if(e.ctrlKey && e.key === 'h'){
        e.preventDefault();
        showHistoryModal();
        moreOptionsMenu.style.display = 'none';
    }
    else if(e.ctrlKey && e.key === 'g'){
        e.preventDefault();
        showPasswordsGeneratorModal();
    }
    else if(e.ctrlKey && e.key === 'z'){
        e.preventDefault();
        showZoom();
    }
    else if(e.ctrlKey && e.key === 'i'){
        e.preventDefault();
        createChatInput();
    }

    if (e.key === 'F12') {
        // Encontra todos os webviews e abre o DevTools para o que está em foco
        const webviews = document.querySelectorAll('webview');
        webviews.forEach(webview => {
            const tabFrame = webview.closest('.tab-frame');
            if (tabFrame && tabFrame.classList.contains('maximized-tab')) {
                webview.openDevTools();
                return; // Encontrou um webview maximizado, pode parar
            }
            
            if (webview.classList.contains('focused') || 
                webview.parentElement.parentElement.classList.contains('focused')) {
                webview.openDevTools();
            }
        });
    }
});

boardsContainer.addEventListener('dragstart', (e) => {
    if (e.target.classList.contains('board-tab')) {
        e.target.classList.add('dragging');
        e.dataTransfer.setData('text/plain', e.target.dataset.boardId);
        e.dataTransfer.effectAllowed = 'move';
    }
});

boardsContainer.addEventListener('dragover', (e) => {
    if (e.target.classList.contains('board-tab')) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        const draggingElement = document.querySelector('.board-tab.dragging');
        const targetElement = e.target;

        if (draggingElement !== targetElement) {
            const rect = targetElement.getBoundingClientRect();
            const nextElement = (e.clientY > rect.top + rect.height / 2) ?
            targetElement.nextElementSibling :
            targetElement;

            boardsContainer.insertBefore(draggingElement, nextElement);
        }
    }
});

boardsContainer.addEventListener('dragend', (e) => {
    if (e.target.classList.contains('board-tab')) {
        e.target.classList.remove('dragging');
    }
});

boardsContainer.addEventListener('drop', (e) => {
    e.preventDefault();
    const boardId = e.dataTransfer.getData('text/plain');
    const boardTab = document.querySelector(`.board-tab[data-board-id="${boardId}"]`);

    if (boardTab && !e.target.classList.contains('board-tab')) {
        // Se soltar em uma área não válida, não faz nada
        return;
    }

    // Atualiza a ordem no localStorage (opcional, se quiser persistência)
    updateBoardsOrder();
});

function updateBoardsOrder() {
    const boardTabs = Array.from(boardsContainer.querySelectorAll('.board-tab'));
    const newOrder = boardTabs.map(tab => tab.dataset.boardId);

    // Reorganiza o objeto `boards` para refletir a nova ordem
    const reorderedBoards = {};
    newOrder.forEach(id => {
        if (boards[id]) {
            reorderedBoards[id] = boards[id];
        }
    });

    boards = reorderedBoards;
    saveState(); // Salva a nova ordem
}

lucide.createIcons();

const sidebar = document.getElementById('sidebar');
const sidebarHeader = document.getElementById('sidebar-header');
const sidebarTitle = document.getElementById('sidebar-title');
const sidebarContent = document.getElementById('sidebar-content');
const sidebarClose = document.getElementById('sidebar-close');

function openSidebar(title, contentHtml) {
  sidebarTitle.textContent = title;
  sidebarContent.innerHTML = contentHtml;
  sidebar.classList.add('open');
}

function closeSidebar() {
  sidebar.classList.remove('open');
  sidebarTitle.textContent = '';
  sidebarContent.innerHTML = '';
}

sidebarClose.addEventListener('click', closeSidebar);

// Settings Sidebar
btnSettings.addEventListener('click', () => {
  openSidebar('Settings', `
    <div class="form-group">
      <label for="startPageInputSidebar">StartPage Webview:</label>
      <input type="text" id="startPageInputSidebar" placeholder="https://example.com" value="${defaultStartPage}" />
    </div>
    <div class="form-group">
      <label for="searchEngineSelectSidebar">Search Engine Default:</label>
      <select id="searchEngineSelectSidebar">
        <option value="google" ${defaultSearchEngine==='google'?'selected':''}>Google</option>
        <option value="duckduckgo" ${defaultSearchEngine==='duckduckgo'?'selected':''}>DuckDuckGo</option>
        <option value="bing" ${defaultSearchEngine==='bing'?'selected':''}>Bing</option>
        <option value="chatgpt" ${defaultSearchEngine==='chatgpt'?'selected':''}>ChatGPT</option>
        <option value="perplexity" ${defaultSearchEngine==='perplexity'?'selected':''}>Perplexity</option>
      </select>
    </div>

    <div class="form-group">
        <label for="enableAISelectSidebar">Enable AI:</label>
        <select id="enableAISelectSidebar">
            <option value="AIdisabled" ${defaultAIOption==='AIdisabled'?'selected':''}>Disabled</option>
            <option value="AIenabled" ${defaultAIOption==='AIenabled'?'selected':''}>Enabled</option>
        </select>
    </div>

    <div class="form-group">
        <button class="modal-button modal-button-secondary" id="btnChangeIcon">Change App Icon</button>
    </div>

    <div class="form-group">
      <button class="modal-button modal-button-secondary" id="btnClearHistorySidebar">Clear Browsing History</button>
    </div>
    <div class="modal-footer">
      <button class="modal-button modal-button-primary" id="btnSaveSettingsSidebar">Save</button>
    </div>
  `);
  document.getElementById('btnChangeIcon').onclick = () => {
    loadIconModal();
    iconModal.style.display = 'flex';
  };

  document.getElementById('btnClearHistorySidebar').onclick = async () => {
    const confirmed = await showConfirm('Are you sure you want to clear the browsing history?');
    if (confirmed) {
      browsingHistory = [];
      localStorage.setItem('browsingHistory', JSON.stringify(browsingHistory));
      showMessage('Browsing history cleared.');
    }
  };



  document.getElementById('btnSaveSettingsSidebar').onclick = () => {
    defaultStartPage = document.getElementById('startPageInputSidebar').value.trim() || 'https://www.google.com';
    defaultSearchEngine = document.getElementById('searchEngineSelectSidebar').value;
    defaultAIOption = document.getElementById('enableAISelectSidebar').value.trim();

    defaultBeforeAIOption = localStorage.getItem('defaultAIOption');
    
    if(defaultAIOption != defaultBeforeAIOption){
        showMessage("Restart your Board Browser to Enable or Disable AI functions!",10000);
    }

    localStorage.setItem('startPage', defaultStartPage);
    localStorage.setItem('searchEngine', defaultSearchEngine);
    localStorage.setItem('defaultAIOption',defaultAIOption);
    closeSidebar();
  };
});

// Password Manager Sidebar
btnCredentials.addEventListener('click', () => {
  let credsHtml = `<div class="credentials-list">`;
  if (savedCredentials.length === 0) {
    credsHtml += '<div class="no-credentials">No saved logins yet.</div>';
  } else {
    savedCredentials.forEach((credential, index) => {
      credsHtml += `
        <div class="credential-item">
          <div class="credential-item-info">
            <strong>${credential.site}</strong><br>
            <small>${credential.username}</small>
          </div>
          <div class="credential-item-actions">
            <button class="btn-use-credential" data-index="${index}" title="Use this login">Use</button>
            <button class="btn-show-credential" data-index="${index}" title="Show">Show</button>
            <button class="btn-delete-credential" data-index="${index}" title="Delete">×</button>
          </div>
        </div>
      `;
    });
  }
  credsHtml += `</div>
    <div class="form-group">
      <h4>Add New Login</h4>
      <div class="credential-form">
        <input type="text" id="credentialSiteSidebar" placeholder="Website (e.g., facebook.com)" required>
        <input type="text" id="credentialUsernameSidebar" placeholder="Username or Email" required>
        <input type="password" id="credentialPasswordSidebar" placeholder="Password" required>
        <button id="btnSaveCredentialSidebar">Save</button>
      </div>
    </div>
  `;
  openSidebar('Password Manager', credsHtml);

  document.querySelectorAll(".btn-show-credential").forEach(btn => {
    btn.addEventListener('click', (e) => {
        const index = e.target.getAttribute('data-index');
        const credential = savedCredentials[index];
        if (credential) {
            // Create a modal to show the credential details
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '50%';
            modal.style.left = '50%';
            modal.style.transform = 'translate(-50%, -50%)';
            modal.style.background = '#333';
            modal.style.color = 'white';
            modal.style.padding = '20px';
            modal.style.borderRadius = '8px';
            modal.style.zIndex = '100001';
            modal.style.width = '300px';
            modal.style.boxShadow = '0 0 20px rgba(0,0,0,0.5)';
            
            modal.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <h3 style="margin-top: 0; color: var(--theme-color);">Login Details</h3>
                    <p><strong>Site:</strong> ${credential.site}</p>
                    <p><strong>Username:</strong> ${credential.username}</p>
                    <p><strong>Password:</strong> <span id="passwordDisplay">••••••••</span></p>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <button id="showPasswordBtn" style="padding: 8px 12px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer;">Show Password</button>
                    <button id="closeCredentialModal" style="padding: 8px 12px; background: #555; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Show password functionality
            const showPasswordBtn = modal.querySelector('#showPasswordBtn');
            const passwordDisplay = modal.querySelector('#passwordDisplay');
            let passwordVisible = false;
            
            showPasswordBtn.addEventListener('click', () => {
                passwordVisible = !passwordVisible;
                passwordDisplay.textContent = passwordVisible ? credential.password : '••••••••';
                showPasswordBtn.textContent = passwordVisible ? 'Hide Password' : 'Show Password';
            });
            
            // Close modal
            modal.querySelector('#closeCredentialModal').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
    });
});


  document.querySelectorAll('.btn-use-credential').forEach(btn => {
    btn.onclick = (e) => {
      const index = e.target.getAttribute('data-index');
      useCredential(index);
      closeSidebar();
    };
  });
  document.querySelectorAll('.btn-delete-credential').forEach(btn => {
    btn.onclick = (e) => {
      const index = e.target.getAttribute('data-index');
      deleteCredential(index);
      closeSidebar();
      btnCredentials.click();
    };
  });


  document.getElementById('btnSaveCredentialSidebar').onclick = () => {
    const site = document.getElementById('credentialSiteSidebar').value.trim();
    const username = document.getElementById('credentialUsernameSidebar').value.trim();
    const password = document.getElementById('credentialPasswordSidebar').value.trim();
    if (!site || !username || !password) {
      showMessage('Please fill all fields');
      return;
    }
    const existingIndex = savedCredentials.findIndex(c => c.site === site && c.username === username);
    if (existingIndex >= 0) {
      savedCredentials[existingIndex].password = password;
    } else {
      savedCredentials.push({ site, username, password });
    }
    saveCredentials();
    closeSidebar();
    btnCredentials.click();
  };
});

// History Sidebar
btnHistory.addEventListener('click', () => {
  let historyHtml = `<div class="form-group"><input type="text" id="historySearchSidebar" class="form-control" placeholder="Search history..."></div><div class="history-list">`;
  if (browsingHistory.length === 0) {
    historyHtml += '<div class="no-history">No browsing history yet.</div>';
  } else {
    browsingHistory.forEach(url => {
      historyHtml += `<div class="history-item" data-url="${url}">${url}</div>`;
    });
  }
  historyHtml += `</div><div class="modal-footer"><button class="modal-button modal-button-secondary" id="btnClearHistorySidebar2">Clear History</button></div>`;
  openSidebar('Browsing History', historyHtml);
  document.getElementById('historySearchSidebar').oninput = (e) => {
    const searchTerm = e.target.value.toLowerCase();
    document.querySelectorAll('.history-item').forEach(item => {
      item.style.display = item.textContent.toLowerCase().includes(searchTerm) ? 'block' : 'none';
    });
  };
  document.querySelectorAll('.history-item').forEach(item => {
    item.onclick = () => {
      createTab(item.dataset.url);
      closeSidebar();
    };
  });
  document.getElementById('btnClearHistorySidebar2').onclick = async () => {
    const confirmed = await showConfirm("Are you sure you want to clear all browsing history?");
    if (confirmed) {
      browsingHistory = [];
      localStorage.setItem('browsingHistory', JSON.stringify(browsingHistory));
      closeSidebar();
      btnHistory.click();
    }
  };
});

// Favorites Sidebar
btnFavorites.addEventListener('click', (e) => {
  e.stopPropagation();
  let favHtml = '<div class="favorites-grid">';
  if (favorites.length === 0) {
    favHtml += '<div class="no-favorites">No favorites yet. Pin websites using the pin button in webview controls.</div>';
  } else {
    favorites.forEach((favorite, index) => {
      favHtml += `<div class="favorite-item" data-url="${favorite.url}">
        <img class="favorite-icon" src="https://www.google.com/s2/favicons?domain=${new URL(favorite.url).hostname}" alt="${favorite.title}">
        <div class="favorite-title">${favorite.title || ''}</div>
      </div>`;
    });
  }
  favHtml += '</div>';
  openSidebar('Favorites', favHtml);
  document.querySelectorAll('.favorite-item').forEach(item => {
    item.onclick = () => {
      createTab(item.dataset.url);
      closeSidebar();
    };
  });
});

// Board Rename Sidebar
btnRenameBoards.addEventListener('click', () => {
  let renameHtml = `<div class="form-group">
    <label for="renameBoardSelectSidebar">Select the Board:</label>
    <select id="renameBoardSelectSidebar" class="form-control">`;
  Object.keys(boards).forEach(boardId => {
    renameHtml += `<option value="${boardId}">${boards[boardId].name}</option>`;
  });
  renameHtml += `</select></div>
    <div class="form-group">
      <label for="renameBoardInputSidebar">New Name:</label>
      <input type="text" id="renameBoardInputSidebar" class="form-control" placeholder="Enter new name">
    </div>
    <div class="modal-footer">
      <button class="modal-button modal-button-primary" id="btnSaveRenameSidebar">Save</button>
    </div>`;
  openSidebar('Rename Board', renameHtml);
  const select = document.getElementById('renameBoardSelectSidebar');
  const input = document.getElementById('renameBoardInputSidebar');
  select.onchange = () => {
    input.value = boards[select.value].name;
  };
  input.value = boards[select.value].name;
  document.getElementById('btnSaveRenameSidebar').onclick = () => {
    const boardId = select.value;
    const newName = input.value.trim();
    if (boardId && newName && boards[boardId]) {
      boards[boardId].name = newName;
      renderBoardTab(boardId, newName);
      closeSidebar();
      saveState();
    }
  };
});

// Board Import Sidebar
btnImportBoards.addEventListener('click', () => {
  let importHtml = `<div class="form-group">
    <label>Select the JSON file:</label>
    <div class="file-input-container">
      <div class="file-input-button">Select File</div>
      <input type="file" id="importFileInputSidebar" class="file-input" accept=".json">
    </div>
    <div id="importFileNameSidebar" class="file-name">No selected files</div>
  </div>
  <div class="form-group">
    <label><input type="checkbox" id="importOverwriteCheckboxSidebar"> Replace existing boards?</label>
  </div>
  <div class="modal-footer">
    <button class="modal-button modal-button-primary" id="btnImportConfirmSidebar" disabled>Import</button>
  </div>`;
  openSidebar('Import Boards', importHtml);
  const fileInput = document.getElementById('importFileInputSidebar');
  const fileName = document.getElementById('importFileNameSidebar');
  const btnImport = document.getElementById('btnImportConfirmSidebar');
  fileInput.onchange = (e) => {
    const file = e.target.files[0];
    if (file) {
      fileName.textContent = file.name;
      btnImport.disabled = false;
    } else {
      fileName.textContent = 'No selected files';
      btnImport.disabled = true;
    }
  };
  btnImport.onclick = () => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const state = JSON.parse(e.target.result);
        if (document.getElementById('importOverwriteCheckboxSidebar').checked) {
          Object.keys(boards).forEach(boardId => {
            closeBoard(boardId);
          });
        }
        boardIdCounter = state.nextBoardId || boardIdCounter;
        tabIdCounter = state.nextTabId || tabIdCounter;
        textFieldIdCounter = state.nextTextFieldId || textFieldIdCounter;
        listIdCounter = state.nextListId || listIdCounter;
        currentZoom = state.currentZoom || 100;
        setZoom(currentZoom);
        if (state.favorites) {
          favorites = state.favorites;
          saveFavorites();
        }
        if (state.drawingData) {
          drawingData = state.drawingData;
          localStorage.setItem('drawingData', JSON.stringify(drawingData));
        }
        if (state.boards) {
          Object.keys(state.boards).forEach(boardId => {
            const savedBoard = state.boards[boardId];
            if (!boards[boardId]) {
              boards[boardId] = {
                id: boardId,
                name: savedBoard.name,
                tabs: [],
                textFields: [],
                lists: [],
                activeTabId: savedBoard.activeTabId,
                activeTextFieldId: savedBoard.activeTextFieldId,
                activeListId: savedBoard.activeListId
              };
              renderBoardTab(boardId, savedBoard.name);
            }
            if (savedBoard.tabs) {
              savedBoard.tabs.forEach(savedTab => {
                createTab(savedTab.url, savedTab, boardId);
              });
            }
            if (savedBoard.textFields) {
              savedBoard.textFields.forEach(savedTextField => {
                createTextField(savedTextField, boardId);
              });
            }
            if (savedBoard.lists) {
              savedBoard.lists.forEach(savedList => {
                createList(savedList, boardId);
              });
            }
          });
        }
        if (state.currentBoardId && boards[state.currentBoardId]) {
          switchBoard(state.currentBoardId, true);
        }
        closeSidebar();
        saveState();
      } catch (error) {
        showMessage("Error in import file: " + error.message);
      }
    };
    reader.readAsText(file);
  };
});

// Board Export Sidebar
btnExportBoards.addEventListener('click', () => {
  let exportHtml = `<div class="form-group">
    <button class="modal-button modal-button-primary" id="btnExportBoardsSidebar">Export Boards as JSON</button>
  </div>`;
  openSidebar('Export Boards', exportHtml);
  document.getElementById('btnExportBoardsSidebar').onclick = () => {
    exportBoards();
    closeSidebar();
  };
});

// Theme Color Sidebar
ctxChangeTheme.addEventListener('click', () => {
  let themeHtml = `<div id="color-picker-container-sidebar">
    <input type="color" id="themeColorInputSidebar" value="${currentThemeColor}">
    <div id="selected-color-preview-sidebar" style="width:100%;height:40px;background:${currentThemeColor};margin-top:10px;"></div>
    <div class="form-group" style="margin-top: 15px;">
      <label for="theme-color-hex-sidebar">HEX:</label>
      <input type="text" id="theme-color-hex-sidebar" value="${currentThemeColor}" readonly>
    </div>
    <div class="modal-footer">
      <button class="modal-button modal-button-secondary" id="btnResetThemeColorSidebar">Reset to Default</button>
      <button class="modal-button modal-button-primary" id="btnSaveThemeColorSidebar">Apply</button>
    </div>
  </div>`;
  openSidebar('Theme Color', themeHtml);
  const colorInput = document.getElementById('themeColorInputSidebar');
  const hexInput = document.getElementById('theme-color-hex-sidebar');
  const preview = document.getElementById('selected-color-preview-sidebar');
  colorInput.oninput = () => {
    hexInput.value = colorInput.value;
    preview.style.background = colorInput.value;
  };
  document.getElementById('btnResetThemeColorSidebar').onclick = () => {
    colorInput.value = '#007acc';
    hexInput.value = '#007acc';
    preview.style.background = '#007acc';
  };
  document.getElementById('btnSaveThemeColorSidebar').onclick = () => {
    const newColor = colorInput.value;
    if (/^#[0-9A-Fa-f]{6}$/.test(newColor)) {
      currentThemeColor = newColor;
      localStorage.setItem('themeColor', newColor);
      applyThemeColor();
      closeSidebar();
    } else {
      showMessage('Please select a valid color.');
    }
  };
  contextMenu.style.display = 'none';
});

[...document.querySelectorAll('.modal-disabled')].forEach(e => e.remove());

function openDownloadsSidebar() {
  let html = `<div class='downloads-list' id='downloadsListSidebar'></div><div class='modal-footer'><button class='modal-button' id='clearDownloadsSidebar'>Clear</button></div>`;
  openSidebar('Downloads', html);
  loadDownloadsSidebar();
  document.getElementById('clearDownloadsSidebar').onclick = clearDownloads;
}
async function loadDownloadsSidebar() {
  try {
    // Carrega downloads ativos e concluídos
    const completedDownloads = await ipcRenderer.invoke('get-completed-downloads');
    const activeDownloadsArray = Array.from(activeDownloads.values());

    const downloadsList = document.getElementById('downloadsListSidebar');
    if (!downloadsList) return;

    if (completedDownloads.length === 0 && activeDownloadsArray.length === 0) {
      downloadsList.innerHTML = `<div class='no-favorites'>No downloads have finished yet.</div>`;
      return;
    }

    const activeHtml = activeDownloadsArray.map(download => `
      <div class='download-item' style='display:flex;align-items:center;justify-content:space-between;padding:12px 10px;background:transparent;border-radius:0;min-height:48px;' id="download-${download.id}">
        <div style='flex:1;'>
          <div style='color:#fff;font-weight:bold;'>${download.fileName}</div>
          <div class='download-details' style='color:#aaa;font-size:12px;'>
            ${formatFileSize(download.receivedBytes)} / ${formatFileSize(download.totalBytes)} • ${download.progress.toFixed(1)}%
          </div>
        </div>
        <div class="download-progress" style="width:100px;height:8px;background-color:#555;border-radius:4px;overflow:hidden;margin-left:10px;">
          <div class="progress-fill" style="width: ${download.progress}%; height:100%; background-color: var(--theme-color);"></div>
        </div>
      </div>
    `).join('');

    const completedHtml = completedDownloads.map(download => `
      <div class='download-item' style='display:flex;align-items:center;justify-content:space-between;padding:12px 10px;background:transparent;border-radius:0;min-height:48px;'>
        <div style='flex:1;'>
          <div style='color:#fff;font-weight:bold;'>${download.fileName}</div>
          <div style='color:#aaa;font-size:12px;'>${download.completedAt} • ${formatFileSize(download.size)}</div>
        </div>
        <div style='color:#4caf50;font-size:18px;margin-left:10px;'>✓</div>
      </div>
    `).join('');

    downloadsList.innerHTML = activeHtml + completedHtml;
  } catch (error) {
    console.error('Error loading sidebar downloads:', error);
    const downloadsList = document.getElementById('downloadsListSidebar');
    if (downloadsList) downloadsList.innerHTML = `<div class='no-favorites'>Error loading downloads.</div>`;
  }
}

const downloadsBtn = document.querySelector('.downloads-btn');
downloadsBtn.onclick = openDownloadsSidebar;
</script>
</body>
</html>
